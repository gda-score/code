# HOW THE FLASK SERVER INTERACTS WITH UBER TOOL

The client sends a request to the Flask server. If the client request does not contain a Session ID i.e., 
`sid` is `''` (Null), then the Flask server initiates a new session and generates a Session ID for the client.
This Session ID is used to uniquely identify the client in future requests. All future requests from the same
client contains this Session ID. The Flask server also writes all the data sent by the client (`budget`, `epsilon`, `dbname`, `query`) to a file which contains the generated Session ID.
This file is read by the Uber Tool. Since this is the start of a session, there is no query associated with it and therefore no result is generated.
Thus, after the first request the Flask server only sends the Session ID it generates back to the client. 

In a future request, the Flask server takes the Session ID that is sent along with the request. The Session ID is used by the Flask server to access the file associated with that particular client.
All data sent by the client in this future request is updated in the file.  
The Uber tool again reads the file and executes the query and returns a `Result` if it is a valid query, otherwise an `Error`.
This file generated by the Uber Tool is read by the Flask Server, formatted as JSON and sent back to the client.

For each session, the used budget by a client is initially set to 0. 
For each query the corresponding `epsilon` value is added to the used budget of a client. 
Once the a client uses its entire budget (`used_budget` > `budget`) the server does not process any further queries and a 
`Error` message is sent back to the client stating `Budget Exceeded - Cannot process queries`.

If there is any unexpected error during query processing and the Flask server takes too long to respond the 
client terminates the connection between the server and itself. This is implemented by a `timeout` on the 
client side. 

# How to use the application

In `config.py` file set the values of `budget` and `dbname`.

Only the `epsilon` value, the `query` and the `count` of query can be updated for each query. 
The `budget` and `dbname` (database name) *CANNOT* be updated once it is set for a particular session.

Make the `querylist` according to the guidelines provided below.

After making the changes in `config.py`, run the script `simpleClientFQDN.py`.

# VALID FORMAT of QUERYLIST SENT BY CLIENT
Send the first query as `NULL` with `'count': 1`.

Make separate `query`, `count` and `epsilon` key-value pairs for each subsequent query.
This query list tells which query to execute how many times and its corresponding `epsilon` value.
The query list can contain as many queries as the user wants. 
What is important is that each `query` *MUST* have a `count` and corresponding `epsilon` value.

When the first `query` is set to `NULL`, it returns just the `Session ID`.
Following valid queries return the query result in `Result` field followed by the Session ID in the `Session ID` field.
When the `budget` set initially by the user is exceeded, query execution stops. 

VALID FORMAT: `{'query': '', 'count': 1}, {'query': 'Some Valid Query', 'count': x, 'epsilon': x}, {'query': 'Some Valid Query', 'count': x, 'epsilon': x}]`

*NOTE 1: `count` is INTEGER while `epsilon` is DOUBLE*

*NOTE 2: Since the first `query` is sent as `NULL` just to get back a Session ID, it has no `epsilon`
value associated with it.*



#INVALID FORMATS of QUERYLIST

Invalid format #1: `[{'query': 'Invalid Query', 'count': 1}, {'query': 'Some Valid Query', 'count': x, 'epsilon': x}]`

This returns the `Session ID` followed by an `'Error': 'syntax error at or near "Invalid"\n'`


Invalid Format #2: `[{'query': '' , 'count': 1}, {'query': 'Invalid Query', 'count': x, 'epsilon': x}]`

E.g., `querylist = [{'query': '', 'count': 1}, {'query': 'SELECT COUNT(*) FROM InvalidTable', 'count': 1, 'epsilon': x}]`

This returns the `Session ID` followed by an `'Error': 'relation "invalidtable" does not exist\n'`


Invalid Format #3: `[{'query': 'Valid/Invalid Query' , 'count': 0}, {'query': 'Valid/Invalid Query', 'count': x, 'epsilon': x}]`

If `count` in first query is set to `0`, no queries (valid/invalid) thereafter will be executed.
It will return only the `Session ID`.

Invalid Format #4: If `count` of any query is 0, the queries before the query with `count` `0` will execute i.e., query with count 0 will not execute.
The following executes only upto `SELECT COUNT(uid) FROM accounts` i.e., second query.

E.g., `querylist = [{'query': '', 'count': 1}, {'query': 'SELECT COUNT(*) FROM accounts', 'count': 1, 'epsilon': x},
              {'query': 'SELECT COUNT(uid) FROM accounts', 'count': 1, 'epsilon': x},
              {'query': 'SELECT COUNT(*) FROM accounts', 'count': 0, 'epsilon': x}]`
              
Invalid Format #4: If any query in between is an inavalid query, all queries are executed and
`Result` field is displayed for valid queries and `Error` field is displayedd for 
invalid queries.

The following executes all queries and displays and `Error` for the second query.

E.g., `querylist = [{'query': '', 'count': 1}, {'query': 'SELECT COUNT(*) FROM InvalidTable', 'count': , 'epsilon': x},
              {'query': 'SELECT COUNT(uid) FROM accounts', 'count': 1, 'epsilon': x}]`


