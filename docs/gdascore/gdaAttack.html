<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>gdascore.gdaAttack API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gdascore.gdaAttack</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import subprocess

import coloredlogs, logging
import sqlite3
import simplejson
import psycopg2
import queue
import threading
import sys
import os
import copy
import base64
import time
import pprint
import datetime
import signal
import atexit
import random


coloredlogs.DEFAULT_FIELD_STYLES[&#39;asctime&#39;] = {}
coloredlogs.DEFAULT_FIELD_STYLES[&#39;levelname&#39;] = {&#39;bold&#39;: True, &#39;color&#39;: &#39;white&#39;, &#39;bright&#39;: True}
coloredlogs.DEFAULT_LEVEL_STYLES[&#39;info&#39;] = {&#39;color&#39;: &#39;cyan&#39;, &#39;bright&#39;: True}
coloredlogs.install(
        fmt=&#34;[%(levelname)s] %(message)s (%(filename)s, %(funcName)s(), line %(lineno)d, %(asctime)s)&#34;,
        datefmt=&#39;%Y-%m-%d %H:%M&#39;,
        level=logging.INFO,
)
# logging.basicConfig(
#         format=&#34;[%(levelname)s] %(message)s (%(filename)s, %(funcName)s(), line %(lineno)d, %(asctime)s)&#34;,
#         datefmt=&#39;%Y-%m-%d %H:%M&#39;,
#         level=logging.INFO,
#     )

# for pdoc documentation
__all__ = [&#34;gdaAttack&#34;]

try:
    from .gdaTools import getInterpolatedValue, getDatabaseInfo
    from .dupCheck import DupCheck
except ImportError:
    from gdaTools import getInterpolatedValue, getDatabaseInfo
    from dupCheck import DupCheck

theCacheQueue = None
theCacheThreadObject = None
flgCacheThreadStarted = False
atcObject = None

class gdaAttack:
    &#34;&#34;&#34;Manages a GDA Attack

       WARNING: this code is fragile, and can fail ungracefully, or
       just hang.&#34;&#34;&#34;

    def __init__(self, params):
        &#34;&#34;&#34; Everything gets set up with &#39;gdaAttack(params)&#39;

            params is a dictionary containing the following
            required parameters: &lt;br/&gt;
            `param[&#39;name&#39;]`: The name of the attack. Make it unique, because
            the cache is discovered using this name. &lt;br/&gt;
            `param[&#39;rawDb&#39;]`: The label for the DB to be used as the
            raw (non-anonymized) DB. &lt;br/&gt;
            Following are the optional parameters: &lt;br/&gt;
            `param[&#39;criteria&#39;]`: The criteria by which the attack should
            determined to succeed or fail. Must be one of &#39;singlingOut&#39;,
            &#39;inference&#39;, or &#39;linkability&#39;. Default is &#39;singlingOut&#39;. &lt;br/&gt;
            `param[&#39;anonDb&#39;]`: The label for the DB to be used as the
            anonymized DB. (Is automatically set to `param[&#39;rawDb&#39;]` if
            not set.) &lt;br/&gt;
            `param[&#39;pubDb&#39;]`: The label for the DB to be used as the
            publicly known DB in linkability attacks. &lt;br/&gt;
            `param[&#39;table&#39;]`: The table to be attacked. Must be present
            if the DB has more than one table. &lt;br/&gt;
            `param[&#39;uid&#39;]`: The uid column for the table. Must be present
            if the name of the column is other than &#39;uid&#39;. &lt;br/&gt;
            `param[&#39;flushCache&#39;]`: Set to true if you want the cache of
            query answers from a previous run flushed. The purpose of the
            cache is to save the work from an aborted attack, which can be
            substantial because attacks can have hundreds of queries. &lt;br/&gt;
            `param[&#39;locCacheDir&#39;]`: The directory holding the cache DBs.
            Default &#39;cacheDBs&#39;. &lt;br/&gt;
            `param[&#39;numRawDbThreads&#39;]`: The number of parallel queries
            that can be made to the raw DB. Default 3. &lt;br/&gt;
            `param[&#39;numAnonDbThreads&#39;]`: The number of parallel queries
            that can be made to the anon DB. Default 3. &lt;br/&gt;
            `param[&#39;numPubDbThreads&#39;]`: The number of parallel queries
            that can be made to the public linkability DB. Default 3. &lt;br/&gt;
            `param[&#39;verbose&#39;]`: Set to True for verbose output.
        &#34;&#34;&#34;

        #### gda-score-code version check warning ####
        process = subprocess.run([sys.executable, &#34;-m&#34;, &#34;pip&#34;, &#34;list&#34;,&#34;--outdated&#34;],stdout=subprocess.PIPE,stderr=subprocess.PIPE,universal_newlines=True)
        upgradable_pkgs = process.stdout
        if &#34;gda-score-code&#34; in upgradable_pkgs:
            pkgs = upgradable_pkgs.split(&#39;\n&#39;)
            potential_gdascore_pkgs = list(filter(lambda x: &#39;gda-score-code&#39; in x, pkgs))
            if len(potential_gdascore_pkgs) == 1:
                gdascore_pkg = potential_gdascore_pkgs[0]
                pkg_name, curr_ver, latest_ver, ins_type = (re.sub(r&#39;\s+&#39;, &#39;|&#39;, gdascore_pkg)
                                                               .split(&#39;|&#39;))
                print(&#39;\n&#39;)
                logging.warning(f&#39;WARNING: You have {pkg_name} version {curr_ver} installed; &#39;
                                f&#39;however, version {latest_ver} is available.&#39;)
                logging.warning(f&#39;You should consider upgrading via the &#39;
                                f&#39;&#34;pip install --upgrade {pkg_name}&#34; command.&#39;)
                print(&#39;\n&#39;)
        ########

        ########### added by frzmohammadali ##########
        global theCacheQueue
        global theCacheThreadObject
        global flgCacheThreadStarted
        global atcObject

        if not theCacheQueue and not theCacheThreadObject:
            theCacheQueue = queue.Queue()
            theCacheThreadObject = CacheThread(theCacheQueue, self)
            atcObject = self
            printTitle(&#39;cache thread initialized.&#39;)

        self.cacheQueue = theCacheQueue
        self.cacheThreadObject = theCacheThreadObject
        if not flgCacheThreadStarted:
            self.cacheThreadObject.start()
            flgCacheThreadStarted = True
        ##############################################

        ############## parameters and instance variables ###############
        # ------------- Class called parameters and configured parameters
        self._vb = False
        self._cr = &#39;&#39;  # short for criteria
        self._pp = None  # pretty printer (for debugging)
        self._colNamesTypes = []
        self._colNames = []
        self._p = dict(name=&#39;&#39;,
                  rawDb=&#39;&#39;,
                  anonDb=&#39;&#39;,
                  pubDb=&#39;&#39;,
                  criteria=&#39;singlingOut&#39;,
                  table=&#39;&#39;,
                  uid=&#39;uid&#39;,
                  flushCache=False,
                  verbose=False,
                  # following not normally set by caller, but can be
                  locCacheDir=&#34;cacheDBs&#34;,
                  numRawDbThreads=3,
                  numAnonDbThreads=3,
                  numPubDbThreads=3,
                  )
        self._requiredParams = [&#39;name&#39;, &#39;rawDb&#39;]

        # ---------- Private internal state
        # Threads
        self._rawThreads = []
        self._anonThreads = []
        self._pubThreads = []
        # Queues read by database threads _rawThreads and _anonThreads
        self._rawQ = None
        self._anonQ = None
        self._pubQ = None
        # Queues read by various caller functions
        self._exploreQ = None
        self._knowledgeQ = None
        self._attackQ = None
        self._claimQ = None
        self._guessQ = None
        # ask/get counters for setting &#39;stillToCome&#39;
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0
        # State for duplicate claim detection
        self._dupCheck = DupCheck()
        # State for computing attack results (see _initAtkRes())
        self._atrs = {}
        # State for various operational measures (see _initOp())
        self._op = {}
        ##############################################

        if self._vb:
            print(f&#34;Calling {__name__}.init&#34;)
        if self._vb:
            print(f&#34;   {params}&#34;)
        self._initOp()
        self._initCounters()
        self._assignGlobalParams(params)
        self._doParamChecks()
        for param in self._requiredParams:
            if len(self._p[param]) == 0:
                s = str(f&#34;Error: Need param &#39;{param}&#39; in class parameters&#34;)
                sys.exit(s)
        # create the database directory if it doesn&#39;t exist
        try:
            if not os.path.exists(self._p[&#39;locCacheDir&#39;]):
                os.makedirs(self._p[&#39;locCacheDir&#39;])
        except OSError:
            sys.exit(&#34;Error: Creating directory. &#34; + self._p[&#39;locCacheDir&#39;])

        # Get the table name if not provided by the caller
        if len(self._p[&#39;table&#39;]) == 0:
            tables = self.getTableNames()
            if len(tables) != 1:
                print(&#34;Error: gdaAttack(): Must include table name if &#34; +
                      &#34;there is more than one table in database&#34;)
                sys.exit()
            self._p[&#39;table&#39;] = tables[0]

        # Get the column names for computing susceptibility later
        self._colNamesTypes = self.getColNamesAndTypes()
        if self._vb:
            print(f&#34;Columns are &#39;{self._colNamesTypes}&#39;&#34;)
        self._initAtkRes()
        # And make a convenient list of column names
        for colNameType in self._colNamesTypes:
            self._colNames.append(colNameType[0])

        # Setup the database which holds already executed queries so we
        # don&#39;t have to repeat them if we are restarting
        self._setupLocalCacheDB()
        # Setup the threads and queues
        self._setupThreadsAndQueues()
        numThreads = threading.active_count()
        expectedThreads = (self._p[&#39;numRawDbThreads&#39;] +
                           self._p[&#39;numAnonDbThreads&#39;] + 1)
        if len(self._p[&#39;pubDb&#39;]) &gt; 0:
            expectedThreads += self._p[&#39;numPubDbThreads&#39;]
        if numThreads &lt; expectedThreads:
            print(f&#34;Error: Some thread(s) died &#34;
                  f&#34;(count {numThreads}, expected {expectedThreads}). &#34;
                  f&#34;Aborting.&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)

    def getResults(self):
        &#34;&#34;&#34; Returns all of the compiled attack results.

            This can be input to class `gdaScores()` and method
            `gdaScores.addResult()`.&#34;&#34;&#34;
        # Add the operational parameters
        self._atrs[&#39;operational&#39;] = self.getOpParameters()
        self._cleanPasswords()
        return self._atrs

    def getOpParameters(self):
        &#34;&#34;&#34; Returns a variety of performance measurements.

            Useful for debugging.&#34;&#34;&#34;
        self._op[&#39;avQueryDuration&#39;] = 0
        if self._op[&#39;numQueries&#39;] &gt; 0:
            self._op[&#39;avQueryDuration&#39;] = (
                    self._op[&#39;timeQueries&#39;] / self._op[&#39;numQueries&#39;])
        self._op[&#39;avCachePutDuration&#39;] = 0
        if self._op[&#39;numCachePuts&#39;] &gt; 0:
            self._op[&#39;avCachePutDuration&#39;] = (
                    self._op[&#39;timeCachePuts&#39;] / self._op[&#39;numCachePuts&#39;])
        self._op[&#39;avCacheGetDuration&#39;] = 0
        if self._op[&#39;numCacheGets&#39;] &gt; 0:
            self._op[&#39;avCacheGetDuration&#39;] = (
                    self._op[&#39;timeCacheGets&#39;] / self._op[&#39;numCacheGets&#39;])
        return self._op

    def setVerbose(self):
        &#34;&#34;&#34;Sets Verbose to True&#34;&#34;&#34;
        self._vb = True

    def unsetVerbose(self):
        &#34;&#34;&#34;Sets Verbose to False&#34;&#34;&#34;
        self._vb = False

    def cleanUp(self, cleanUpCache=True, doExit=False,
                exitMsg=&#34;Finished cleanUp, exiting&#34;):
        &#34;&#34;&#34; Garbage collect queues, threads, and cache.

            By default, this wipes the cache. The idea being that if the
            entire attack finished successfully, then it won&#39;t be
            repeated and the cache isn&#39;t needed. Do `cleanUpCache=False`
            if that isn&#39;t what you want.&#34;&#34;&#34;
        if self._vb: print(f&#34;Calling {__name__}.cleanUp&#34;)
        if self._rawQ.empty() != True:
            logging.warning(&#34;Warning, trying to clean up when raw queue not empty!&#34;)
        if self._anonQ.empty() != True:
            logging.warning(&#34;Warning, trying to clean up when anon queue not empty!&#34;)
        if self.cacheQueue.empty() != True:
            logging.warning(&#34;Warning, trying to clean up when cache queue not empty!&#34;)
        # Stuff in end signals for the workers (this is a bit bogus, cause
        # if a thread is gone or hanging, not all signals will get read)
        for i in range(self._p[&#39;numRawDbThreads&#39;]):
            self._rawQ.put(None)
        for i in range(self._p[&#39;numAnonDbThreads&#39;]):
            self._anonQ.put(None)

        for i in range(self.cacheQueue.qsize()):
            self.cacheQueue.put(None)

        cleanBgThreads()

        if len(self._p[&#39;pubDb&#39;]) &gt; 0:
            if self._pubQ.empty() != True:
                print(&#34;Warning, trying to clean up when pub queue not empty!&#34;)
            for i in range(self._p[&#39;numPubDbThreads&#39;]):
                self._pubQ.put(None)
            for t in self._pubThreads:
                if t.isAlive(): t.stop() # t.join()
        if cleanUpCache:
            self._removeLocalCacheDB()
        if doExit:
            sys.exit(exitMsg)

    def isClaimed(self, spec):
        &#34;&#34;&#34;Check if a claim was already fully or partially made.

        The `spec` is formatted identical to the `spec` in `gdaAttack.askClaim`.&#34;&#34;&#34;
        return self._dupCheck.is_claimed(spec, verbose=self._vb)

    def askClaim(self, spec, cache=True, claim=True):
        &#34;&#34;&#34;Generate Claim query for raw and optionally pub databases.

        Before anything happens, the system uses the `gdaAttack.isClaimed`
        method to determine whether a previous claim fully or partially
        matches the new claim. Such duplicates are not allowed and an error
        will be raised providing additional details about the duplicate.

        Making a claim results in a query to the raw database, and if
        linkability attack, the pub database, to check
        the correctness of the claim. Multiple calls to this method will
        cause the corresponding queries to be queued up, so `askClaim()`
        returns immediately. `getClaim()` harvests one claim result. &lt;br/&gt;
        Set `claim=False` if this claim should not be applied to the
        confidence improvement score. In this case, the probability score
        will instead be reduced accordingly. &lt;br/&gt;
        The `spec` is formatted as follows: &lt;br/&gt;

            {&#39;known&#39;:[{&#39;col&#39;:&#39;colName&#39;,&#39;val&#39;:&#39;value&#39;},...],
              &#39;guess&#39;:[{&#39;col&#39;:&#39;colName&#39;,&#39;val&#39;:&#39;value&#39;},...],
            }

        `spec[&#39;known&#39;]` are the columns and values the attacker already knows
        (i.e. with prior knowledge). Optional. &lt;br/&gt;
        `spec[&#39;guess&#39;]` are the columns and values the attacker doesn&#39;t know,
        but rather is trying to predict. Mandatory for &#39;singling out&#39;
        and &#39;inference&#39;. Optional for &#39;linkabiblity&#39; &lt;br/&gt;
        Answers are cached &lt;br/&gt;
        Returns immediately&#34;&#34;&#34;
        if self._vb: print(f&#34;Calling {__name__}.askClaim with spec &#39;{spec}&#39;, count {self._claimCounter}&#34;)
        if not self._dupCheck.is_claimed(spec, verbose=self._vb, raise_true=True):
            self._dupCheck.claim(spec, verbose=self._vb)
        self._claimCounter += 1
        sql = self._makeSqlFromSpec(spec)
        if self._vb: print(f&#34;Sql is &#39;{sql}&#39;&#34;)
        sqlConfs = self._makeSqlConfFromSpec(spec)
        if self._vb: print(f&#34;SqlConf is &#39;{sqlConfs}&#39;&#34;)
        # Make a copy of the query for passing around
        job = {}
        job[&#39;q&#39;] = self._claimQ
        job[&#39;claim&#39;] = claim
        job[&#39;queries&#39;] = [{&#39;sql&#39;: sql, &#39;cache&#39;: cache}]
        job[&#39;spec&#39;] = spec
        for sqlConf in sqlConfs:
            job[&#39;queries&#39;].append({&#39;sql&#39;: sqlConf, &#39;cache&#39;: cache})
        self._rawQ.put(job)

    def getClaim(self):
        &#34;&#34;&#34; Wait for and gather results of askClaim() calls

            Returns a data structure that contains both the result
            of one finished claim, and the claim&#39;s input parameters.
            Note that the order in which results are returned by
            `getClaim()` are not necessarily the same order they were
            inserted by `askClaim()`. &lt;br/&gt;
            Assuming `result` is returned: &lt;br/&gt;
            `result[&#39;claim&#39;]` is the value supplied in the corresponding
            `askClaim()` call &lt;br/&gt;
            `result[&#39;spec&#39;]` is a copy of the `spec` supplied in the
            corresponding `askClaim()` call. &lt;br/&gt;
            `result[&#39;queries&#39;]` is a list of the queries generated in order to
            validate the claim. &lt;br/&gt;
            `result[&#39;answers&#39;]` are the answers to the queries in
            `result[&#39;queries&#39;]`. &lt;br/&gt;
            `result[&#39;claimResult&#39;]` is &#39;Correct&#39; or &#39;Incorrect&#39;, depending
            on whether the claim satisfies the critieria or not. &lt;br/&gt;
            `result[&#39;stillToCome&#39;]` is a counter showing how many more
            claims are still queued. When `stillToCome` is 0, then all
            claims submitted by `askClaim()` have been returned.&#34;&#34;&#34;

        if self._vb:
            print(f&#34;Calling {__name__}.getClaim&#34;)
        if self._claimCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0, &#39;claimResult&#39;: &#39;Error&#39;}
        job = self._claimQ.get()
        claim = job[&#39;claim&#39;]
        self._claimQ.task_done()
        self._claimCounter -= 1
        job[&#39;stillToCome&#39;] = self._claimCounter
        self._addToAtkRes(&#39;claimTrials&#39;, job[&#39;spec&#39;], 1)
        # The claim is tested against the first reply
        reply = job[&#39;replies&#39;][0]
        job[&#39;claimResult&#39;] = &#39;Wrong&#39;
        if claim:
            self._addToAtkRes(&#39;claimMade&#39;, job[&#39;spec&#39;], 1)
        if &#39;error&#39; in reply:
            self._addToAtkRes(&#39;claimError&#39;, job[&#39;spec&#39;], 1)
            job[&#39;claimResult&#39;] = &#39;Error&#39;
        else:
            if self._cr == &#39;singlingOut&#39;:
                claimIsCorrect = self._checkSinglingOut(reply[&#39;answer&#39;])
            elif self._cr == &#39;inference&#39;:
                claimIsCorrect = self._checkInference(reply[&#39;answer&#39;])
            elif self._cr == &#39;linkability&#39;:
                claimIsCorrect = self._checkLinkability(reply[&#39;answer&#39;])
            if claim == 1 and claimIsCorrect:
                self._addToAtkRes(&#39;claimCorrect&#39;, job[&#39;spec&#39;], 1)
                job[&#39;claimResult&#39;] = &#39;Correct&#39;
            elif claim == 0 and claimIsCorrect:
                self._addToAtkRes(&#39;claimPassCorrect&#39;, job[&#39;spec&#39;], 1)
                job[&#39;claimResult&#39;] = &#39;Correct&#39;
        if self._cr == &#39;singlingOut&#39; or self._cr == &#39;inference&#39;:
            # Then measure confidence against the second and third replies
            if &#39;answer&#39; in job[&#39;replies&#39;][1]:
                if job[&#39;replies&#39;][1][&#39;answer&#39;]:
                    guessedRows = job[&#39;replies&#39;][1][&#39;answer&#39;][0][0]
                else:
                    guessedRows = 0
            elif &#39;error&#39; in job[&#39;replies&#39;][1]:
                self._pp.pprint(job)
                print(f&#34;Error: conf query:\n{job[&#39;replies&#39;][1][&#39;error&#39;]}&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if &#39;answer&#39; in job[&#39;replies&#39;][2]:
                if job[&#39;replies&#39;][2][&#39;answer&#39;]:
                    totalRows = job[&#39;replies&#39;][2][&#39;answer&#39;][0][0]
                else:
                    totalRows = 0
            elif &#39;error&#39; in job[&#39;replies&#39;][2]:
                self._pp.pprint(job)
                print(f&#34;Error: conf query:\n{job[&#39;replies&#39;][2][&#39;error&#39;]}&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if totalRows:
                self._addToAtkRes(&#39;sumConfidenceRatios&#39;, job[&#39;spec&#39;],
                                  guessedRows / totalRows)
                self._addToAtkRes(&#39;numConfidenceRatios&#39;, job[&#39;spec&#39;], 1)
                self._atrs[&#39;tableStats&#39;][&#39;totalRows&#39;] = totalRows
        else:
            # For linkability, the confidence is always 1/2
            self._addToAtkRes(&#39;sumConfidenceRatios&#39;, job[&#39;spec&#39;], 0.5)
            self._addToAtkRes(&#39;numConfidenceRatios&#39;, job[&#39;spec&#39;], 1)
        if &#39;q&#39; in job:
            del job[&#39;q&#39;]
        return (job)

    def askAttack(self, query, cache=True):
        &#34;&#34;&#34; Generate and queue up an attack query for database.

            `query` is a dictionary with (currently) one value: &lt;br/&gt;
            `query[&#39;sql&#39;] contains the SQL query.&#34;&#34;&#34;
        self._attackCounter += 1
        if self._vb: print(f&#34;Calling {__name__}.askAttack with query &#39;{query}&#39;, count {self._attackCounter}&#34;)
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job[&#39;q&#39;] = self._attackQ
        qCopy[&#39;cache&#39;] = cache
        job[&#39;queries&#39;] = [qCopy]
        self._anonQ.put(job)

    def getAttack(self):
        &#34;&#34;&#34; Returns the result of one askAttack() call

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askAttack()` calls were made. &lt;br/&gt;
            Assuming `result` is returned: &lt;br/&gt;
            `result[&#39;answer&#39;]` is the answer returned by the DB. The
            format is: &lt;br/&gt;
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` &lt;br/&gt;
            where C1 is the first element of the `SELECT`, C2 the second
            element, etc. &lt;br/&gt;
            `result[&#39;cells&#39;]` is the number of cells returned in the answer
            (used by `gdaAttack()` to compute total attack cells) &lt;br/&gt;
            `result[&#39;query&#39;][&#39;sql&#39;]` is the query from the corresponding
            `askAttack()`.&#34;&#34;&#34;

        if self._vb:
            print(f&#34;Calling {__name__}.getAttack&#34;)
        if self._attackCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0}
        job = self._attackQ.get()
        self._attackQ.task_done()
        self._attackCounter -= 1
        reply = job[&#39;replies&#39;][0]
        reply[&#39;stillToCome&#39;] = self._attackCounter
        self._atrs[&#39;base&#39;][&#39;attackGets&#39;] += 1
        if &#39;cells&#39; in reply:
            if reply[&#39;cells&#39;] == 0:
                self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += 1
            else:
                self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += reply[&#39;cells&#39;]
        else:
            self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += 1
        return (reply)

    def askKnowledge(self, query, cache=True):
        &#34;&#34;&#34; Generate and queue up a prior knowledge query for database

            The class keeps track of how many prior knowledge cells were
            returned and uses this to compute a score. &lt;br/&gt;
            Input parameters formatted the same as with `askAttack()`&#34;&#34;&#34;

        self._knowledgeCounter += 1
        if self._vb: print(f&#34;Calling {__name__}.askKnowledge with query &#34;
                           f&#34;&#39;{query}&#39;, count {self._knowledgeCounter}&#34;)
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job[&#39;q&#39;] = self._knowledgeQ
        qCopy[&#39;cache&#39;] = cache
        job[&#39;queries&#39;] = [qCopy]
        self._rawQ.put(job)

    def getKnowledge(self):
        &#34;&#34;&#34; Wait for and gather results of prior askKnowledge() calls

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askKnowledge()` calls were made. &lt;br/&gt;
            Return parameter formatted the same as with `getAttack()`&#34;&#34;&#34;

        if self._vb:
            print(f&#34;Calling {__name__}.getKnowledge&#34;)
        if self._knowledgeCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0}
        job = self._knowledgeQ.get()
        self._knowledgeQ.task_done()
        self._knowledgeCounter -= 1
        reply = job[&#39;replies&#39;][0]
        reply[&#39;stillToCome&#39;] = self._knowledgeCounter
        self._atrs[&#39;base&#39;][&#39;knowledgeGets&#39;] += 1
        if &#39;cells&#39; in reply:
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += reply[&#39;cells&#39;]
        return (reply)

    def askExplore(self, query, cache=True):
        &#34;&#34;&#34; Generate and queue up an exploritory query for database

            No score book-keeping is done here. An analyst may make
            any number of queries without impacting the GDA score. &lt;br/&gt;
            `query` is a dictionary with two values: &lt;br/&gt;
            `query[&#39;sql&#39;]` contains the SQL query. &lt;br/&gt;
            `query[&#39;db&#39;]` determines which database is queried, and
            is one of &#39;rawDb&#39;, &#39;anonDb&#39;, or (if linkability), &#39;pubDb&#39;.&#34;&#34;&#34;

        self._exploreCounter += 1
        if self._vb: print(f&#34;Calling {__name__}.askExplore with &#34;
                           f&#34;query &#39;{query}&#39;, count {self._exploreCounter}&#34;)
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job[&#39;q&#39;] = self._exploreQ
        qCopy[&#39;cache&#39;] = cache
        job[&#39;queries&#39;] = [qCopy]
        if qCopy[&#39;db&#39;] == &#39;rawDb&#39; or qCopy[&#39;db&#39;] == &#39;raw&#39;:
            self._rawQ.put(job)
        elif qCopy[&#39;db&#39;] == &#39;anonDb&#39; or qCopy[&#39;db&#39;] == &#39;anon&#39;:
            self._anonQ.put(job)
        else:
            self._pubQ.put(job)

    def getExplore(self):
        &#34;&#34;&#34; Wait for and gather results of prior askExplore() calls.

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askExplore()` calls were made. &lt;br/&gt;
            Return parameter formatted the same as with `getAttack()`&#34;&#34;&#34;
        if self._vb:
            print(f&#34;Calling {__name__}.getExplore&#34;)
        if self._exploreCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0}
        job = self._exploreQ.get()
        self._exploreQ.task_done()
        self._exploreCounter -= 1
        reply = job[&#39;replies&#39;][0]
        reply[&#39;stillToCome&#39;] = self._exploreCounter
        return (reply)

    def getPublicColValues(self, colName, tableName=&#39;&#39;):
        &#34;&#34;&#34;Return list of &#34;publicly known&#34; column values and counts

        Column value has index 0, count of distinct UIDs has index 1
        Must specify column name.
        &#34;&#34;&#34;
        if len(colName) == 0:
            print(f&#34;Must specify column &#39;colName&#39;&#34;)
            return None

        if len(tableName) == 0:
            # caller didn&#39;t supply a table name, so get it from the
            # class init
            tableName = self._p[&#39;table&#39;]

        # Establish connection to database
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # First we need to know the total number of distinct users
        sql = str(f&#34;&#34;&#34;select count(distinct {self._p[&#39;uid&#39;]})
                      from {tableName}&#34;&#34;&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        numUid = ans[0][0]
        # Query the raw db for values in the column
        sql = str(f&#34;&#34;&#34;select {colName}, count(distinct {self._p[&#39;uid&#39;]})
                      from {tableName}
                      group by 1
                      order by 2 desc
                      limit 200&#34;&#34;&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            # row[0] is the value, row[1] is the count
            if (((row[1] / numUid) &gt; 0.002) and
                    (row[1] &gt;= 50)):
                ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getColNames(self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;):
        &#34;&#34;&#34;Return simple list of column names

        `dbType` is one of &#39;rawDb&#39; or &#39;anonDb&#39;&#34;&#34;&#34;

        if len(tableName) == 0:
            colsAndTypes = self.getColNamesAndTypes(dbType=dbType)
        else:
            colsAndTypes = self.getColNamesAndTypes(
                dbType=dbType, tableName=tableName)
        if not colsAndTypes:
            return None
        cols = []
        for tup in colsAndTypes:
            cols.append(tup[0])
        return cols

    def getAttackTableName(self):
        &#34;&#34;&#34;Returns the name of the table being used in the attack.&#34;&#34;&#34;
        return self._p[&#39;table&#39;]

    def getTableCharacteristics(self, tableName=&#39;&#39;):
        &#34;&#34;&#34;Returns the full contents of the table characteristics

           Return value is a dict indexed by column name: &lt;br/&gt;

               { &#39;&lt;colName&gt;&#39;:
                   {
                       &#39;av_rows_per_vals&#39;: 3.93149,
                       &#39;av_uids_per_val&#39;: 0.468698,
                       &#39;column_label&#39;: &#39;continuous&#39;,
                       &#39;column_name&#39;: &#39;dropoff_latitude&#39;,
                       &#39;column_type&#39;: &#39;real&#39;,
                       &#39;max&#39;: &#39;898.29382000000000&#39;,
                       &#39;min&#39;: &#39;-0.56333297000000&#39;,
                       &#39;num_distinct_vals&#39;: 24216,
                       &#39;num_rows&#39;: 95205,
                       &#39;num_uids&#39;: 11350,
                       &#39;std_rows_per_val&#39;: 10.8547,
                       &#39;std_uids_per_val&#39;: 4.09688},
                   }
               }

        &#34;&#34;&#34;
        if len(tableName) == 0:
            # caller didn&#39;t supply a table name, so get it from the
            # class init
            tableName = self._p[&#39;table&#39;]

        # Modify table name to the default for the characteristics table
        tableName += &#39;_char&#39;

        # Establish connection to database
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Set up return dict
        ret = {}
        # Query it for column names
        sql = str(f&#34;&#34;&#34;select column_name, data_type 
                  from information_schema.columns where
                  table_name=&#39;{tableName}&#39;&#34;&#34;&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getTableCharacteristics() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        cols = cur.fetchall()
        # Make index for column name (should be 0, but just to be sure)
        for colNameIndex in range(len(cols)):
            if cols[colNameIndex][0] == &#39;column_name&#39;:
                break

        # Query it for table contents
        sql = str(f&#34;SELECT * FROM {tableName}&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getTableCharacteristics() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        for row in ans:
            colName = row[colNameIndex]
            ret[colName] = {}
            for i in range(len(row)):
                ret[colName][cols[i][0]] = row[i]
        conn.close()
        return ret

    # Note that following is used internally, but we expose it to the
    # caller as well because it is a useful function for exploration
    def getColNamesAndTypes(self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;):
        &#34;&#34;&#34;Return raw database column names and types (or None if error)

        dbType is one of &#39;rawDb&#39; or &#39;anonDb&#39; &lt;br/&gt;
        return format: [(col,type),(col,type),...]&#34;&#34;&#34;
        if len(tableName) == 0:
            # caller didn&#39;t supply a table name, so get it from the
            # class init
            tableName = self._p[&#39;table&#39;]

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db[&#39;type&#39;] != &#39;postgres&#39; and db[&#39;type&#39;] != &#39;aircloak&#39;:
            print(f&#34;DB type &#39;{db[&#39;type&#39;]}&#39; must be &#39;postgres&#39; or &#39;aircloak&#39;&#34;)
            return None
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db[&#39;type&#39;] == &#39;postgres&#39;:
            sql = str(f&#34;&#34;&#34;select column_name, data_type 
                      from information_schema.columns where
                      table_name=&#39;{tableName}&#39;&#34;&#34;&#34;)
        elif db[&#39;type&#39;] == &#39;aircloak&#39;:
            sql = str(f&#34;show columns from {tableName}&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getColNamesAndTypes() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getTableNames(self, dbType=&#39;rawDb&#39;):
        &#34;&#34;&#34;Return database table names

        dbType is one of &#39;rawDb&#39; or &#39;anonDb&#39; &lt;br/&gt;
        Table names returned as list, unless error then return None&#34;&#34;&#34;

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db[&#39;type&#39;] != &#39;postgres&#39; and db[&#39;type&#39;] != &#39;aircloak&#39;:
            print(f&#34;DB type &#39;{db[&#39;type&#39;]}&#39; must be &#39;postgres&#39; or &#39;aircloak&#39;&#34;)
            return None
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db[&#39;type&#39;] == &#39;postgres&#39;:
            sql = &#34;&#34;&#34;SELECT tablename
                     FROM pg_catalog.pg_tables
                     WHERE schemaname != &#39;pg_catalog&#39; AND
                           schemaname != &#39;information_schema&#39;&#34;&#34;&#34;
        elif db[&#39;type&#39;] == &#39;aircloak&#39;:
            sql = &#34;show tables&#34;
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getTableNames() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append(row[0])
        conn.close()
        return ret

    def getUidColName(self):
        &#34;&#34;&#34; Returns the name of the UID column&#34;&#34;&#34;
        return self._p[&#39;uid&#39;]

    def getPriorKnowledge(self, dataColumns, method,
            fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):
        &#34;&#34;&#34; Returns data from the rawDB according to a specification

        This mimics external knowledge that an attacker may have about the data, and
        influences the &#39;knowledge&#39; part of the GDA Score. &lt;br/&gt;
            `dataColumns` is a list of column names. The data for these columns is returned &lt;br/&gt;
            `method` can be &#39;rows&#39; or &#39;users&#39;. If &#39;rows&#39;, then rows are selected
            according to the criteria (`fraction`, `count`, `selectColumn`, `colRange`,
            or `values`).
            If &#39;users&#39;, then all rows for a set of selected users is returned.
            The users are selected according to the criteria (`fraction` or `count`) &lt;br/&gt;
            If none of the criteria are set, or if `fraction` is set to 1.0, then all
            rows are returned (for the selected column values) One of `fraction`, `count`,
            or `selectColumn` must be set. &lt;br/&gt;
            `fraction` or `count` are set to obtain a random set of rows or users. If
            `fraction`, then an approximate fraction of all rows/users is selected.
            `fraction` is a value between 0 and 1.0. If `count`, then exactly `count`
            random rows/users are selected. &lt;br/&gt;
            `selectColumn` is set to select rows according to the values of the specified
            column. `selectColumn` is a column name. If set, then either a range of
            values (`colRange`), or a set of values (`values`) must be chosen. &lt;br/&gt;
            `colRange` is
            a list with two values: `[min,max]`. This selects all values
            between min and max inclusive. &lt;br/&gt;
            `values` is a list
            of one or more values of any type. This selects all values matching those in
            the list. &lt;br/&gt;
            The return value is a list in this format: &lt;br/&gt;
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` &lt;br/&gt;
            where C1 corresponds to the first column in `dataColumns`, C2 corresponds to
            the second column in `dataColumns`, and so on.  &lt;br/&gt;
        &#34;&#34;&#34;
        # Check input parameters
        if not isinstance(dataColumns, list):
            print(f&#34;getPriorKnowledge Error: dataColumns must be a list of one or more column names&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if method not in [&#39;rows&#39;,&#39;users&#39;]:
            print(f&#34;getPriorKnowledge Error: method must be &#39;rows&#39; or &#39;users&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction is None and count is None and selectColumn is None:
            print(f&#34;getPriorKnowledge Error: one of fraction, count, or selectColumn must be set&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction and not isinstance(fraction, float):
            print(f&#34;getPriorKnowledge Error: if set, fraction must be a float&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if (fraction and (count or selectColumn)) or (count and (fraction or selectColumn)):
            print(f&#34;getPriorKnowledge Error: only one of fraction, count, or selectColumn may be set&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if count and not isinstance(count, int):
            print(f&#34;getPriorKnowledge Error: if set, count must be an integer&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if selectColumn:
            if selectColumn not in self._colNames:
                print(f&#34;getPriorKnowledge Error: selectColumn &#39;{selectColumn}&#39; is not a valid column&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if colRange == [None,None] and values == [None]:
                print(f&#34;getPriorKnowledge Error: if selectColumn is set, one of colRange or values must be set&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not isinstance(colRange, list):
                print(f&#34;getPriorKnowledge Error: colRange must be a list with two values&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not (isinstance(values, list) or isinstance(values, tuple)) or len(values) == 0:
                print(f&#34;getPriorKnowledge Error: values must be a list or tuple with one or more values&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
        for col in dataColumns:
            if col not in self._colNames:
                print(f&#34;getPriorKnowledge Error: column &#39;{col}&#39; is not a valid column&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
        # Basic input checks finished
        # Establish connection to database
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        table = self._p[&#39;table&#39;]
        uid = self._p[&#39;uid&#39;]
        # Make the SELECT part of the SQL query
        initSql = &#39;SELECT &#39;
        for col in dataColumns:
            initSql += str(f&#34;{col}, &#34;)
        initSql = initSql[0:-2]
        if method == &#39;rows&#39; and fraction:
            sql = initSql + str(f&#34; FROM {table} WHERE random() &lt;= {fraction}&#34;)
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;users&#39; and fraction:
            sql = initSql + str(f&#34; FROM {table} WHERE {uid} IN &#34;)
            sql += str(f&#34;(SELECT {uid} from (SELECT DISTINCT {uid} FROM {table}) t WHERE random() &lt; {fraction})&#34;)
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;rows&#39; and colRange[0] is not None:
            for pair in self._colNamesTypes:
                if selectColumn in pair[0]:
                    colType = pair[1]
                    break
            if &#39;text&#39; in colType or &#39;char&#39; in colType or &#39;date&#39; in colType or &#39;time&#39; in colType:
                sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} &gt;= &#39;{colRange[0]}&#39; and {selectColumn} &lt;= &#39;{colRange[1]}&#39;&#34;)
            else:
                sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} &gt;= {colRange[0]} and {selectColumn} &lt;= {colRange[1]}&#34;)
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;rows&#39; and values[0] is not None:
            sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} IN (&#34;)
            for pair in self._colNamesTypes:
                if selectColumn in pair[0]:
                    colType = pair[1]
                    break
            for value in values:
                if &#34;text&#34; in colType or &#34;date&#34; in colType or &#34;time&#34; in colType:
                    sql += str(f&#34;&#39;{value}&#39;, &#34;)
                else:
                    sql += str(f&#34;{value}, &#34;)
            sql = sql[0:-2]
            sql += &#34;)&#34;
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;rows&#39; and count:
            # need to know the total number of rows
            sql = str(f&#34;select count(*) from {table}&#34;)
            ans = self._doQuery(cur,sql)
            numRows = ans[0][0]
            # next we get some random set of rows that is certainly more than we need
            frac = (count/numRows)*2
            sql = initSql + str(f&#34; FROM {table} WHERE random() &lt;= {frac}&#34;)
            temp = self._doQuery(cur,sql)
            # next we scramble these so that we get a random sampling from the random sampling
            random.shuffle(temp)
            # finally pick the exact count
            ans = temp[0:count]
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;users&#39; and count:
            # get the full list of distinct UIDs
            sql = str(f&#34;SELECT DISTINCT {uid} from {table}&#34;)
            uidList = self._doQuery(cur,sql)
            # next we scramble these so that we can get a random sampling
            random.shuffle(uidList)
            # pick the exact count of UIDs
            uidList = uidList[0:count]
            sql = initSql + str(f&#34; FROM {table} WHERE {uid} IN (&#34;)
            for pair in self._colNamesTypes:
                if uid in pair[0]:
                    colType = pair[1]
                    break
            for uidVal in uidList:
                if &#34;text&#34; in colType or &#34;date&#34; in colType or &#34;time&#34; in colType:
                    sql += str(f&#34;&#39;{uidVal[0]}&#39;, &#34;)
                else:
                    sql += str(f&#34;{uidVal[0]}, &#34;)
            sql = sql[0:-2]
            sql += &#34;)&#34;
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        #zzzz
        return None
    #def getPriorKnowledge(self, dataColumns, method,
            #fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):

    # -------------- Private Methods -------------------
    def _doQuery(self,cur,sql):
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        return ans

    def _cleanPasswords(self):
        if &#39;attack&#39; in self._atrs:
            if (&#39;anonDb&#39; in self._atrs[&#39;attack&#39;] and
                    &#39;password&#39; in self._atrs[&#39;attack&#39;][&#39;anonDb&#39;]):
                self._atrs[&#39;attack&#39;][&#39;anonDb&#39;][&#39;password&#39;] = &#39;xxxxxxx&#39;
            if (&#39;rawDb&#39; in self._atrs[&#39;attack&#39;] and
                    &#39;password&#39; in self._atrs[&#39;attack&#39;][&#39;rawDb&#39;]):
                self._atrs[&#39;attack&#39;][&#39;rawDb&#39;][&#39;password&#39;] = &#39;xxxxxxx&#39;
            if (&#39;pubDb&#39; in self._atrs[&#39;attack&#39;] and
                    &#39;password&#39; in self._atrs[&#39;attack&#39;][&#39;pubDb&#39;]):
                self._atrs[&#39;attack&#39;][&#39;pubDb&#39;][&#39;password&#39;] = &#39;xxxxxxx&#39;

        return

    def _assignGlobalParams(self, params):
        self._pp = pprint.PrettyPrinter(indent=4)
        for key, val in params.items():
            self._p[key] = val
            # assign verbose value to a smaller variable name
            if key == &#34;verbose&#34;:
                if val != False:
                    self._vb = True
            # Check criteria
            if key == &#34;criteria&#34;:
                if (val == &#39;singlingOut&#39; or val == &#39;inference&#39; or
                        val == &#39;linkability&#39;):
                    self._cr = val
                else:
                    print(&#34;&#34;&#34;Error: criteria must be one of &#39;singlingOut&#39;,
                             &#39;inference&#39;, or &#39;linkability&#39;&#34;&#34;&#34;)
                    sys.exit(&#39;&#39;)

    def _setupLocalCacheDB(self):
        path = self._p[&#39;locCacheDir&#39;] + &#34;/&#34; + self._p[&#39;name&#39;] + &#34;.db&#34;
        conn = sqlite3.connect(path)
        cur = conn.cursor()
        if self._p[&#39;flushCache&#39;] == True:
            sql = &#34;DROP TABLE IF EXISTS tab&#34;
            if self._vb: print(f&#34;   cache DB: {sql}&#34;)
            cur.execute(sql)
        sql = &#34;&#34;&#34;CREATE TABLE IF NOT EXISTS tab
                 (qid text, answer text)&#34;&#34;&#34;
        if self._vb: print(f&#34;   cache DB: {sql}&#34;)
        cur.execute(sql)
        conn.close()

    def _removeLocalCacheDB(self):
        path = self._p[&#39;locCacheDir&#39;] + &#34;/&#34; + self._p[&#39;name&#39;] + &#34;.db&#34;
        max_attempts = 5
        attempt = 0
        removeFlag = False
        _ex = None
        if os.path.exists(path):
            while attempt &lt;= max_attempts:
                attempt += 1
                try:
                    os.remove(path)
                    removeFlag = True
                    break
                except Exception as ex:
                    _ex = ex
                    removeFlag = False
                time.sleep(0.3)

            if not removeFlag:
                logging.error(f&#34;cache db removing error after {attempt} attempts.\n&#34;
                              f&#34;ERROR: Failed to remove cache DB {path} =&gt; ex: {_ex}&#34;)
            else:
                logging.info(f&#34;cache db removed successfully after {attempt} attempt(s).&#34;)

    def removeLocalCacheDBWrapper(self):
        return self._removeLocalCacheDB()

    def _setupThreadsAndQueues(self):
        self._anonThreads = []
        self._rawThreads = []
        self._pubThreads = []
        self._exploreQ = queue.Queue()
        self._knowledgeQ = queue.Queue()
        self._attackQ = queue.Queue()
        self._claimQ = queue.Queue()
        self._guessQ = queue.Queue()
        self._rawQ = queue.Queue()
        if self._cr == &#39;linkability&#39;:
            self._pubQ = queue.Queue()
        self._anonQ = queue.Queue()
        backQ = queue.Queue()
        for i in range(self._p[&#39;numRawDbThreads&#39;]):
            d = dict(db=self._p[&#39;rawDb&#39;], q=self._rawQ,
                     kind=&#39;raw&#39;, backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._rawThreads.append(t)
        for i in range(self._p[&#39;numAnonDbThreads&#39;]):
            d = dict(db=self._p[&#39;anonDb&#39;], q=self._anonQ,
                     kind=&#39;anon&#39;, backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._anonThreads.append(t)
        if self._cr == &#39;linkability&#39;:
            for i in range(self._p[&#39;numPubDbThreads&#39;]):
                d = dict(db=self._p[&#39;pubDb&#39;], q=self._pubQ,
                         kind=&#39;pub&#39;, backQ=backQ)
                t = EnhancedThread(target=self._dbWorker, kwargs=d)
                t.start()
                self._pubThreads.append(t)
        num = (self._p[&#39;numRawDbThreads&#39;] + self._p[&#39;numAnonDbThreads&#39;])
        if self._cr == &#39;linkability&#39;:
            num += self._p[&#39;numPubDbThreads&#39;]
        # Make sure all the worker threads are ready
        for i in range(num):
            msg = backQ.get()
            if self._vb: print(f&#34;{msg} is ready&#34;)
            backQ.task_done()

    def _dbWorker(self, db, q, kind, backQ):
        if self._vb: print(f&#34;Starting {__name__}.dbWorker:{db, kind}&#34;)
        me = threading.current_thread()
        d = getDatabaseInfo(db)
        # Establish connection to database
        connStr = str(
            f&#34;host={d[&#39;host&#39;]} port={d[&#39;port&#39;]} dbname={d[&#39;dbname&#39;]} user={d[&#39;user&#39;]} password={d[&#39;password&#39;]}&#34;)
        if self._vb: print(f&#34;    {me}: Connect to DB with DSN &#39;{connStr}&#39;&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Establish connection to local cache
        path = self._p[&#39;locCacheDir&#39;] + &#34;/&#34; + self._p[&#39;name&#39;] + &#34;.db&#34;
        # Set timeout low so that we don&#39;t spend a lot of time inserting
        # into the cache in case it gets overloaded
        connInsert = sqlite3.connect(path, timeout=0.1)
        curInsert = connInsert.cursor()
        connRead = sqlite3.connect(path)
        curRead = connRead.cursor()
        backQ.put(me)
        while True:
            if isinstance(me, EnhancedThread) and me.stopped():
                logging.info(f&#39; &gt; {me.getName()} stopped.&#39;)
                return
            try:
                jobOrig = q.get(block=True, timeout=3)
            except queue.Empty:
                continue
            q.task_done()
            if jobOrig is None:
                if self._vb: print(f&#34;    {me}: dbWorker done {db, kind}&#34;)
                conn.close()
                connRead.close()
                connInsert.close()
                break
            # make a copy for passing around
            job = copy.copy(jobOrig)
            replyQ = job[&#39;q&#39;]
            replies = []
            for query in job[&#39;queries&#39;]:
                reply = self._processQuery(query, conn, cur,
                                           connInsert, curInsert, curRead)
                replies.append(reply)
            job[&#39;replies&#39;] = replies
            replyQ.put(job)

    def _processQuery(self, query, conn, cur, connInsert, curInsert, curRead):
        # record and remove the return queue
        cache = query[&#39;cache&#39;]
        del query[&#39;cache&#39;]
        # Check the cache for the answer
        # Note that at this point query is a dict
        # containing the sql, the db (raw, anon, or pub),
        # and any tags that the source added
        cachedReply = None
        if cache:
            cachedReply = self._getCache(curRead, query)
        if cachedReply:
            if self._vb: print(&#34;    Answer from cache&#34;)
            if &#39;answer&#39; in cachedReply:
                numCells = self._computeNumCells(cachedReply[&#39;answer&#39;])
                cachedReply[&#39;cells&#39;] = numCells
            return cachedReply
        else:
            start = time.perf_counter()
            try:
                cur.execute(query[&#39;sql&#39;])
            except psycopg2.Error as e:
                reply = dict(error=e.pgerror)
            else:
                ans = cur.fetchall()
                numCells = self._computeNumCells(ans)
                reply = dict(answer=ans, cells=numCells)
            end = time.perf_counter()
            duration = end - start
            self._op[&#39;numQueries&#39;] += 1
            self._op[&#39;timeQueries&#39;] += duration
            reply[&#39;query&#39;] = query
            # only cache if the native query is slow
            if duration &gt; 0.1:
                # self._putCache(connInsert, curInsert, query, reply)
                self.cacheQueue.put([connInsert, curInsert, query, reply])
            return reply

    def _checkInference(self, ans):
        # column 0 must be UID
        # User is inferred if all users in answer have same attributes
        # Returns 1 if inference claim correct, else returns 0
        if len(ans) == 0:
            return 0
        numRows = len(ans)
        numColumns = len(ans[0])
        if numColumns &lt; 2:
            # Can&#39;t test inference unless there is at least one column
            # (other than UID) that is the same
            return 0
        for c in range(1, numColumns):
            val = ans[0][c]
            for r in range(1, numRows):
                if val != ans[r][c]:
                    return 0
        return 1

    def _checkLinkability(self, ans):
        # The test is the same as with singling out
        # Returns 1 if linkability claim correct, else returns 0
        return self._checkSinglingOut(ans)

    def _checkSinglingOut(self, ans):
        # column 0 must be UID
        # User is singled-out if there is only one distinct UID
        # Returns 1 if singling out claim correct, else returns 0
        if len(ans) == 0:
            return 0
        uids = {}
        for row in ans:
            uids[row[0]] = 1
        numUids = len(uids)
        if numUids == 1:
            return 1
        else:
            return 0

    def _computeNumCells(self, ans):
        # ans is a list of tuples [(x,y),(x,y),(x,y) ...
        # Count the number of columns (in the first row)
        if len(ans) == 0:
            return 0
        numColumns = len(ans[0])
        numRows = len(ans)
        numCells = numColumns * numRows
        return numCells

    def _doParamChecks(self):
        dbInfoRaw = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        if not dbInfoRaw:
            sys.exit(&#39;rawDb now found in database config&#39;)
        if len(self._p[&#39;anonDb&#39;]) == 0:
            self._p[&#39;anonDb&#39;] = self._p[&#39;rawDb&#39;]
        else:
            dbInfoAnon = getDatabaseInfo(self._p[&#39;anonDb&#39;])
            if not dbInfoAnon:
                sys.exit(&#39;anonDb not found in database config&#39;)
        if self._cr == &#39;linkability&#39;:
            dbInfo = getDatabaseInfo(self._p[&#39;pubDb&#39;])
            if not dbInfo:
                sys.exit(&#39;Must specify pubDb if criteria is linkability&#39;)
        numThreads = self._p[&#39;numRawDbThreads&#39;] + self._p[&#39;numAnonDbThreads&#39;]
        if self._cr == &#39;linkability&#39;:
            numThreads += self._p[&#39;numPubDbThreads&#39;]
        if numThreads &gt; 50:
            sys.exit(&#34;Error: Can&#39;t have more than 50 threads total&#34;)

    def _getCache(self, cur, query):
        # turn the query (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return None
        sql = str(f&#34;SELECT answer FROM tab where qid = &#39;{qStr}&#39;&#34;)
        if self._vb: print(f&#34;   cache DB: {sql}&#34;)
        start = time.perf_counter()
        try:
            cur.execute(sql)
        except sqlite3.Error as e:
            print(f&#34;getCache error &#39;{e.args[0]}&#39;&#34;)
            return None
        end = time.perf_counter()
        self._op[&#39;numCacheGets&#39;] += 1
        self._op[&#39;timeCacheGets&#39;] += (end - start)
        answer = cur.fetchone()
        if not answer:
            return None
        rtnDict = self._str2Dict(answer[0])
        return rtnDict

    def _putCache(self, conn, cur, query, reply):
        # turn the query and reply (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return
        rStr = self._dict2Str(reply)
        if rStr is None:
            return
        sql = str(f&#34;INSERT INTO tab VALUES (&#39;{qStr}&#39;,&#39;{rStr}&#39;)&#34;)
        if self._vb: print(f&#34;   cache DB: {sql}&#34;)
        start = time.perf_counter()
        err = None
        for z in range(10):
            try:
                cur.execute(sql)
                conn.commit()
            except sqlite3.OperationalError as e:
                if self._p[&#39;verbose&#39;] or self._vb:
                    print(f&#34;putCache error &#39;{e.args[0]}&#39;&#34;)
                err = e
                continue
            except sqlite3.Error as e:
                if self._p[&#39;verbose&#39;] or self._vb:
                    print(f&#34;putCache error &#39;{e.args[0]}&#39;&#34;)
                err = e
                continue
            else:
                break
        else:
            # raise err
            if self._p[&#39;verbose&#39;] or self._vb:
                print(f&#39;&gt;&gt; could not insert into cache DB &gt;&gt; ERROR: {err}&#39;)

        end = time.perf_counter()
        self._op[&#39;numCachePuts&#39;] += 1
        self._op[&#39;timeCachePuts&#39;] += (end - start)

    def putCacheWrapper(self, conn, cur, query, reply):
        self._putCache(conn, cur, query, reply)

    def _dict2Str(self, d):
        try:
            dStr = simplejson.dumps(d)
        except TypeError:
            print(&#34;simpleJson failed&#34;)
            return None
        dByte = str.encode(dStr)
        dByte64 = base64.b64encode(dByte)
        try:
            dByte64Str = str(dByte64, &#34;utf-8&#34;)
        except MemoryError:
            print(&#34;str(dByte64) failed&#34;)
            return None
        return dByte64Str

    def _str2Dict(self, dByte64Str):
        dByte64 = str.encode(dByte64Str)
        dByte = base64.b64decode(dByte64)
        dStr = str(dByte, &#34;utf-8&#34;)
        d = simplejson.loads(dStr)
        return d

    def _makeSqlFromSpec(self, spec):
        sql = &#34;select &#34;
        if &#39;known&#39; in spec:
            numKnown = len(spec[&#39;known&#39;])
        else:
            numKnown = 0
        if &#39;guess&#39; in spec:
            numGuess = len(spec[&#39;guess&#39;])
        else:
            numGuess = 0
        if self._cr == &#39;inference&#39;:
            sql += str(f&#34;{self._p[&#39;uid&#39;]}, &#34;)
            for i in range(numGuess):
                sql += str(f&#34;{spec[&#39;guess&#39;][i][&#39;col&#39;]}&#34;)
                if i == (numGuess - 1):
                    sql += &#34; &#34;
                else:
                    sql += &#34;, &#34;
            sql += str(f&#34;from {self._p[&#39;table&#39;]} &#34;)
            if numKnown:
                sql += &#34;where &#34;
            for i in range(numKnown):
                sql += str(f&#34;{spec[&#39;known&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;known&#39;][i][&#39;val&#39;]}&#39; &#34;)
                if i == (numKnown - 1):
                    sql += &#34; &#34;
                else:
                    sql += &#34;and &#34;
        elif self._cr == &#39;singlingOut&#39; or self._cr == &#39;linkability&#39;:
            sql += str(f&#34;{self._p[&#39;uid&#39;]} from {self._p[&#39;table&#39;]} where &#34;)
            for i in range(numKnown):
                sql += str(f&#34;{spec[&#39;known&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;known&#39;][i][&#39;val&#39;]}&#39; and &#34;)
            for i in range(numGuess):
                sql += str(f&#34;{spec[&#39;guess&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;guess&#39;][i][&#39;val&#39;]}&#39; &#34;)
                if i == (numGuess - 1):
                    sql += &#34; &#34;
                else:
                    sql += &#34;and &#34;
        return sql

    def _makeSqlConfFromSpec(self, spec):
        sqls = []
        numGuess = len(spec[&#39;guess&#39;])
        if self._cr == &#39;inference&#39; or self._cr == &#39;singlingOut&#39;:
            sql = str(f&#34;select count(distinct {self._p[&#39;uid&#39;]}) from {self._p[&#39;table&#39;]} where &#34;)
            # This first sql learns the number of rows matching the
            # guessed values
            for i in range(numGuess):
                sql += str(f&#34;{spec[&#39;guess&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;guess&#39;][i][&#39;val&#39;]}&#39;&#34;)
                if i != (numGuess - 1):
                    sql += &#34; and &#34;
            sqls.append(sql)
            # This second sql learns the total number of rows (should
            # normally be a cached result)
            sql = str(f&#34;select count(distinct {self._p[&#39;uid&#39;]}) from {self._p[&#39;table&#39;]}&#34;)
            sqls.append(sql)
        elif self._cr == &#39;linkability&#39;:
            # nothing happens for linkability
            pass
        return sqls

    def _addToAtkRes(self, label, spec, val):
        &#34;&#34;&#34;Adds the value to each column in the guess&#34;&#34;&#34;
        for tup in spec[&#39;guess&#39;]:
            col = tup[&#39;col&#39;]
            if col not in self._atrs[&#39;col&#39;]:
                print(f&#34;Error: addToAtkRes(): Bad column in spec: &#39;{col}&#39;&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if label not in self._atrs[&#39;col&#39;][col]:
                print(f&#34;Error: addToAtkRes(): Bad label &#39;{label}&#39;&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            self._atrs[&#39;col&#39;][col][label] += val

    def _initAtkRes(self):
        self._atrs = {}
        self._atrs[&#39;attack&#39;] = {}
        self._atrs[&#39;base&#39;] = {}
        self._atrs[&#39;tableStats&#39;] = {}
        self._atrs[&#39;col&#39;] = {}
        # ----- Attack parameters
        self._atrs[&#39;attack&#39;][&#39;attackName&#39;] = self._p[&#39;name&#39;]
        self._atrs[&#39;attack&#39;][&#39;rawDb&#39;] = self._p[&#39;rawDb&#39;]
        self._atrs[&#39;attack&#39;][&#39;anonDb&#39;] = self._p[&#39;anonDb&#39;]
        if self._cr == &#39;linkability&#39;:
            self._atrs[&#39;attack&#39;][&#39;pubDb&#39;] = self._p[&#39;anonDb&#39;]
        self._atrs[&#39;attack&#39;][&#39;criteria&#39;] = self._p[&#39;criteria&#39;]
        self._atrs[&#39;attack&#39;][&#39;table&#39;] = self._p[&#39;table&#39;]
        # add parameters for the database machine itself
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        self._atrs[&#39;attack&#39;][&#39;rawHost&#39;] = db[&#39;host&#39;]
        self._atrs[&#39;attack&#39;][&#39;rawDbName&#39;] = db[&#39;dbname&#39;]
        self._atrs[&#39;attack&#39;][&#39;rawPort&#39;] = db[&#39;port&#39;]
        if self._cr == &#39;linkability&#39;:
            db = getDatabaseInfo(self._p[&#39;pubDb&#39;])
            self._atrs[&#39;attack&#39;][&#39;pubHost&#39;] = db[&#39;host&#39;]
            self._atrs[&#39;attack&#39;][&#39;pubDbName&#39;] = db[&#39;dbname&#39;]
            self._atrs[&#39;attack&#39;][&#39;pubPort&#39;] = db[&#39;port&#39;]
        db = getDatabaseInfo(self._p[&#39;anonDb&#39;])
        self._atrs[&#39;attack&#39;][&#39;anonHost&#39;] = db[&#39;host&#39;]
        self._atrs[&#39;attack&#39;][&#39;anonDbName&#39;] = db[&#39;dbname&#39;]
        self._atrs[&#39;attack&#39;][&#39;anonPort&#39;] = db[&#39;port&#39;]
        # and a timestamp
        self._atrs[&#39;attack&#39;][&#39;startTime&#39;] = str(datetime.datetime.now())
        # ----- Params for computing knowledge:
        # number of prior knowledge cells requested
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] = 0
        # number of times knowledge was queried
        self._atrs[&#39;base&#39;][&#39;knowledgeGets&#39;] = 0

        # ----- Params for computing how much work needed to attack:
        # number of attack cells requested
        self._atrs[&#39;base&#39;][&#39;attackCells&#39;] = 0
        # number of times attack was queried
        self._atrs[&#39;base&#39;][&#39;attackGets&#39;] = 0
        self._atrs[&#39;tableStats&#39;][&#39;colNamesAndTypes&#39;] = self._colNamesTypes
        self._atrs[&#39;tableStats&#39;][&#39;numColumns&#39;] = len(self._colNamesTypes)
        for tup in self._colNamesTypes:
            col = tup[0]
            if self._vb: print(f&#34;initAtkRes() init column &#39;{col}&#39;&#34;)
            self._atrs[&#39;col&#39;][col] = {}

            # ----- Params for computing claim success rate:
            # total possible number of claims
            self._atrs[&#39;col&#39;][col][&#39;claimTrials&#39;] = 0
            # actual number of claims
            self._atrs[&#39;col&#39;][col][&#39;claimMade&#39;] = 0
            # number of correct claims
            self._atrs[&#39;col&#39;][col][&#39;claimCorrect&#39;] = 0
            # number of claims that produced bad SQL answer
            self._atrs[&#39;col&#39;][col][&#39;claimError&#39;] = 0
            # claims where the attacker chose to pass (not make a claim),
            # but where the claim would have been correct
            self._atrs[&#39;col&#39;][col][&#39;claimPassCorrect&#39;] = 0

            # ----- Params for computing confidence:
            # sum of all known count to full count ratios
            self._atrs[&#39;col&#39;][col][&#39;sumConfidenceRatios&#39;] = 0
            # number of such ratios
            self._atrs[&#39;col&#39;][col][&#39;numConfidenceRatios&#39;] = 0
            # average confidence ratio (division of above two params)
            self._atrs[&#39;col&#39;][col][&#39;avgConfidenceRatios&#39;] = 0

    def _initOp(self):
        self._op[&#39;numQueries&#39;] = 0
        self._op[&#39;timeQueries&#39;] = 0
        self._op[&#39;numCachePuts&#39;] = 0
        self._op[&#39;timeCachePuts&#39;] = 0
        self._op[&#39;numCacheGets&#39;] = 0
        self._op[&#39;timeCacheGets&#39;] = 0

    def _initCounters(self):
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0


class EnhancedThread(threading.Thread):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.daemon = True
        self._stopFlag = threading.Event()

    def stop(self):
        self._stopFlag.set()

    def stopped(self):
        return self._stopFlag.isSet()


class CacheThread(EnhancedThread):
    def __init__(self, theQueue, atcObject):
        super().__init__()
        self.theQueue = theQueue
        self.atcObject = atcObject
        self.name = self.getName() + &#34; (cache thread)&#34;
        self.dbConnection = None

    def run(self):
        while True:
            if self.stopped():
                logging.info(f&#39; &gt; {self.getName()} stopped.&#39;)
                break
            try:
                data = self.theQueue.get(block=True, timeout=3)
            except queue.Empty:
                continue
            if data is not None:
                self.atcObject.putCacheWrapper(*data)
                self.dbConnection = data[0] # this is connInsert for closing later
                if self.atcObject._p[&#39;verbose&#39;] or self.atcObject._vb:
                    printTitle(&#39;cache insert successful. queue length: &#39; + str(self.theQueue.qsize()))
            self.theQueue.task_done()

    def stop(self):
        logging.debug(&#34;CacheThread received stop signal&#34;)
        super().stop()
        if self.dbConnection:
            try:
                self.dbConnection.interrupt()
            except sqlite3.ProgrammingError:
                pass
            else:
                logging.debug(&#34;interrupt signal sent to cacheDb for safe deleting cacheDb file later.&#34;)



def cleanBgThreads():
    for t in threading.enumerate():
        if isinstance(t, EnhancedThread) and (not t.stopped()):
            t.stop()
            t.join(timeout=1.0)

def printTitle(text):
    print(f&#39;\n{&#34; &#34;+text:-&gt;46}\n&#39;)

def signal_kill_handler(signum, frame):
    global atcObject
    printTitle(&#34;Terminating the program ...&#34;)
    thread_info = (
        (f&#39;    &gt;&gt; {set([t.name for t in threading.enumerate() if t != threading.main_thread()])} \n&#39;
        f&#39; &gt; sending termination signal to all. please wait ... &#39;) if threading.active_count() &gt; 1
                                                                   else &#39;&#39;
    )
    logging.info(f&#39;\n &gt; active background threads: {threading.active_count() - 1} \n&#39;
                 f&#39;{thread_info}&#39;)
    # logging.info(f&#39;\n &gt; active background threads: {threading.active_count() - 1} \n&#39;
    #              f&#39;    &gt;&gt; {set([t.name for t in threading.enumerate() if t != threading.main_thread()])} \n&#39;
    #              f&#39; &gt; sending termination signal to all. please wait ... &#39;)
    cleanBgThreads()
    if atcObject:
        atcObject.cleanUp()

    sys.exit(-1)

def on_exit():
    if len([t for t in threading.enumerate() if isinstance(t, EnhancedThread) and (not t.stopped())]):
        cleanBgThreads()
    while threading.active_count() &gt; 1:
        pass

signal.signal(signal.SIGTERM, signal_kill_handler)
signal.signal(signal.SIGINT, signal_kill_handler)

atexit.register(on_exit)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gdascore.gdaAttack.gdaAttack"><code class="flex name class">
<span>class <span class="ident">gdaAttack</span></span>
<span>(</span><span>params)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages a GDA Attack</p>
<p>WARNING: this code is fragile, and can fail ungracefully, or
just hang.</p>
<p>Everything gets set up with 'gdaAttack(params)'</p>
<p>params is a dictionary containing the following
required parameters: <br/>
<code>param['name']</code>: The name of the attack. Make it unique, because
the cache is discovered using this name. <br/>
<code>param['rawDb']</code>: The label for the DB to be used as the
raw (non-anonymized) DB. <br/>
Following are the optional parameters: <br/>
<code>param['criteria']</code>: The criteria by which the attack should
determined to succeed or fail. Must be one of 'singlingOut',
'inference', or 'linkability'. Default is 'singlingOut'. <br/>
<code>param['anonDb']</code>: The label for the DB to be used as the
anonymized DB. (Is automatically set to <code>param['rawDb']</code> if
not set.) <br/>
<code>param['pubDb']</code>: The label for the DB to be used as the
publicly known DB in linkability attacks. <br/>
<code>param['table']</code>: The table to be attacked. Must be present
if the DB has more than one table. <br/>
<code>param['uid']</code>: The uid column for the table. Must be present
if the name of the column is other than 'uid'. <br/>
<code>param['flushCache']</code>: Set to true if you want the cache of
query answers from a previous run flushed. The purpose of the
cache is to save the work from an aborted attack, which can be
substantial because attacks can have hundreds of queries. <br/>
<code>param['locCacheDir']</code>: The directory holding the cache DBs.
Default 'cacheDBs'. <br/>
<code>param['numRawDbThreads']</code>: The number of parallel queries
that can be made to the raw DB. Default 3. <br/>
<code>param['numAnonDbThreads']</code>: The number of parallel queries
that can be made to the anon DB. Default 3. <br/>
<code>param['numPubDbThreads']</code>: The number of parallel queries
that can be made to the public linkability DB. Default 3. <br/>
<code>param['verbose']</code>: Set to True for verbose output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class gdaAttack:
    &#34;&#34;&#34;Manages a GDA Attack

       WARNING: this code is fragile, and can fail ungracefully, or
       just hang.&#34;&#34;&#34;

    def __init__(self, params):
        &#34;&#34;&#34; Everything gets set up with &#39;gdaAttack(params)&#39;

            params is a dictionary containing the following
            required parameters: &lt;br/&gt;
            `param[&#39;name&#39;]`: The name of the attack. Make it unique, because
            the cache is discovered using this name. &lt;br/&gt;
            `param[&#39;rawDb&#39;]`: The label for the DB to be used as the
            raw (non-anonymized) DB. &lt;br/&gt;
            Following are the optional parameters: &lt;br/&gt;
            `param[&#39;criteria&#39;]`: The criteria by which the attack should
            determined to succeed or fail. Must be one of &#39;singlingOut&#39;,
            &#39;inference&#39;, or &#39;linkability&#39;. Default is &#39;singlingOut&#39;. &lt;br/&gt;
            `param[&#39;anonDb&#39;]`: The label for the DB to be used as the
            anonymized DB. (Is automatically set to `param[&#39;rawDb&#39;]` if
            not set.) &lt;br/&gt;
            `param[&#39;pubDb&#39;]`: The label for the DB to be used as the
            publicly known DB in linkability attacks. &lt;br/&gt;
            `param[&#39;table&#39;]`: The table to be attacked. Must be present
            if the DB has more than one table. &lt;br/&gt;
            `param[&#39;uid&#39;]`: The uid column for the table. Must be present
            if the name of the column is other than &#39;uid&#39;. &lt;br/&gt;
            `param[&#39;flushCache&#39;]`: Set to true if you want the cache of
            query answers from a previous run flushed. The purpose of the
            cache is to save the work from an aborted attack, which can be
            substantial because attacks can have hundreds of queries. &lt;br/&gt;
            `param[&#39;locCacheDir&#39;]`: The directory holding the cache DBs.
            Default &#39;cacheDBs&#39;. &lt;br/&gt;
            `param[&#39;numRawDbThreads&#39;]`: The number of parallel queries
            that can be made to the raw DB. Default 3. &lt;br/&gt;
            `param[&#39;numAnonDbThreads&#39;]`: The number of parallel queries
            that can be made to the anon DB. Default 3. &lt;br/&gt;
            `param[&#39;numPubDbThreads&#39;]`: The number of parallel queries
            that can be made to the public linkability DB. Default 3. &lt;br/&gt;
            `param[&#39;verbose&#39;]`: Set to True for verbose output.
        &#34;&#34;&#34;

        #### gda-score-code version check warning ####
        process = subprocess.run([sys.executable, &#34;-m&#34;, &#34;pip&#34;, &#34;list&#34;,&#34;--outdated&#34;],stdout=subprocess.PIPE,stderr=subprocess.PIPE,universal_newlines=True)
        upgradable_pkgs = process.stdout
        if &#34;gda-score-code&#34; in upgradable_pkgs:
            pkgs = upgradable_pkgs.split(&#39;\n&#39;)
            potential_gdascore_pkgs = list(filter(lambda x: &#39;gda-score-code&#39; in x, pkgs))
            if len(potential_gdascore_pkgs) == 1:
                gdascore_pkg = potential_gdascore_pkgs[0]
                pkg_name, curr_ver, latest_ver, ins_type = (re.sub(r&#39;\s+&#39;, &#39;|&#39;, gdascore_pkg)
                                                               .split(&#39;|&#39;))
                print(&#39;\n&#39;)
                logging.warning(f&#39;WARNING: You have {pkg_name} version {curr_ver} installed; &#39;
                                f&#39;however, version {latest_ver} is available.&#39;)
                logging.warning(f&#39;You should consider upgrading via the &#39;
                                f&#39;&#34;pip install --upgrade {pkg_name}&#34; command.&#39;)
                print(&#39;\n&#39;)
        ########

        ########### added by frzmohammadali ##########
        global theCacheQueue
        global theCacheThreadObject
        global flgCacheThreadStarted
        global atcObject

        if not theCacheQueue and not theCacheThreadObject:
            theCacheQueue = queue.Queue()
            theCacheThreadObject = CacheThread(theCacheQueue, self)
            atcObject = self
            printTitle(&#39;cache thread initialized.&#39;)

        self.cacheQueue = theCacheQueue
        self.cacheThreadObject = theCacheThreadObject
        if not flgCacheThreadStarted:
            self.cacheThreadObject.start()
            flgCacheThreadStarted = True
        ##############################################

        ############## parameters and instance variables ###############
        # ------------- Class called parameters and configured parameters
        self._vb = False
        self._cr = &#39;&#39;  # short for criteria
        self._pp = None  # pretty printer (for debugging)
        self._colNamesTypes = []
        self._colNames = []
        self._p = dict(name=&#39;&#39;,
                  rawDb=&#39;&#39;,
                  anonDb=&#39;&#39;,
                  pubDb=&#39;&#39;,
                  criteria=&#39;singlingOut&#39;,
                  table=&#39;&#39;,
                  uid=&#39;uid&#39;,
                  flushCache=False,
                  verbose=False,
                  # following not normally set by caller, but can be
                  locCacheDir=&#34;cacheDBs&#34;,
                  numRawDbThreads=3,
                  numAnonDbThreads=3,
                  numPubDbThreads=3,
                  )
        self._requiredParams = [&#39;name&#39;, &#39;rawDb&#39;]

        # ---------- Private internal state
        # Threads
        self._rawThreads = []
        self._anonThreads = []
        self._pubThreads = []
        # Queues read by database threads _rawThreads and _anonThreads
        self._rawQ = None
        self._anonQ = None
        self._pubQ = None
        # Queues read by various caller functions
        self._exploreQ = None
        self._knowledgeQ = None
        self._attackQ = None
        self._claimQ = None
        self._guessQ = None
        # ask/get counters for setting &#39;stillToCome&#39;
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0
        # State for duplicate claim detection
        self._dupCheck = DupCheck()
        # State for computing attack results (see _initAtkRes())
        self._atrs = {}
        # State for various operational measures (see _initOp())
        self._op = {}
        ##############################################

        if self._vb:
            print(f&#34;Calling {__name__}.init&#34;)
        if self._vb:
            print(f&#34;   {params}&#34;)
        self._initOp()
        self._initCounters()
        self._assignGlobalParams(params)
        self._doParamChecks()
        for param in self._requiredParams:
            if len(self._p[param]) == 0:
                s = str(f&#34;Error: Need param &#39;{param}&#39; in class parameters&#34;)
                sys.exit(s)
        # create the database directory if it doesn&#39;t exist
        try:
            if not os.path.exists(self._p[&#39;locCacheDir&#39;]):
                os.makedirs(self._p[&#39;locCacheDir&#39;])
        except OSError:
            sys.exit(&#34;Error: Creating directory. &#34; + self._p[&#39;locCacheDir&#39;])

        # Get the table name if not provided by the caller
        if len(self._p[&#39;table&#39;]) == 0:
            tables = self.getTableNames()
            if len(tables) != 1:
                print(&#34;Error: gdaAttack(): Must include table name if &#34; +
                      &#34;there is more than one table in database&#34;)
                sys.exit()
            self._p[&#39;table&#39;] = tables[0]

        # Get the column names for computing susceptibility later
        self._colNamesTypes = self.getColNamesAndTypes()
        if self._vb:
            print(f&#34;Columns are &#39;{self._colNamesTypes}&#39;&#34;)
        self._initAtkRes()
        # And make a convenient list of column names
        for colNameType in self._colNamesTypes:
            self._colNames.append(colNameType[0])

        # Setup the database which holds already executed queries so we
        # don&#39;t have to repeat them if we are restarting
        self._setupLocalCacheDB()
        # Setup the threads and queues
        self._setupThreadsAndQueues()
        numThreads = threading.active_count()
        expectedThreads = (self._p[&#39;numRawDbThreads&#39;] +
                           self._p[&#39;numAnonDbThreads&#39;] + 1)
        if len(self._p[&#39;pubDb&#39;]) &gt; 0:
            expectedThreads += self._p[&#39;numPubDbThreads&#39;]
        if numThreads &lt; expectedThreads:
            print(f&#34;Error: Some thread(s) died &#34;
                  f&#34;(count {numThreads}, expected {expectedThreads}). &#34;
                  f&#34;Aborting.&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)

    def getResults(self):
        &#34;&#34;&#34; Returns all of the compiled attack results.

            This can be input to class `gdaScores()` and method
            `gdaScores.addResult()`.&#34;&#34;&#34;
        # Add the operational parameters
        self._atrs[&#39;operational&#39;] = self.getOpParameters()
        self._cleanPasswords()
        return self._atrs

    def getOpParameters(self):
        &#34;&#34;&#34; Returns a variety of performance measurements.

            Useful for debugging.&#34;&#34;&#34;
        self._op[&#39;avQueryDuration&#39;] = 0
        if self._op[&#39;numQueries&#39;] &gt; 0:
            self._op[&#39;avQueryDuration&#39;] = (
                    self._op[&#39;timeQueries&#39;] / self._op[&#39;numQueries&#39;])
        self._op[&#39;avCachePutDuration&#39;] = 0
        if self._op[&#39;numCachePuts&#39;] &gt; 0:
            self._op[&#39;avCachePutDuration&#39;] = (
                    self._op[&#39;timeCachePuts&#39;] / self._op[&#39;numCachePuts&#39;])
        self._op[&#39;avCacheGetDuration&#39;] = 0
        if self._op[&#39;numCacheGets&#39;] &gt; 0:
            self._op[&#39;avCacheGetDuration&#39;] = (
                    self._op[&#39;timeCacheGets&#39;] / self._op[&#39;numCacheGets&#39;])
        return self._op

    def setVerbose(self):
        &#34;&#34;&#34;Sets Verbose to True&#34;&#34;&#34;
        self._vb = True

    def unsetVerbose(self):
        &#34;&#34;&#34;Sets Verbose to False&#34;&#34;&#34;
        self._vb = False

    def cleanUp(self, cleanUpCache=True, doExit=False,
                exitMsg=&#34;Finished cleanUp, exiting&#34;):
        &#34;&#34;&#34; Garbage collect queues, threads, and cache.

            By default, this wipes the cache. The idea being that if the
            entire attack finished successfully, then it won&#39;t be
            repeated and the cache isn&#39;t needed. Do `cleanUpCache=False`
            if that isn&#39;t what you want.&#34;&#34;&#34;
        if self._vb: print(f&#34;Calling {__name__}.cleanUp&#34;)
        if self._rawQ.empty() != True:
            logging.warning(&#34;Warning, trying to clean up when raw queue not empty!&#34;)
        if self._anonQ.empty() != True:
            logging.warning(&#34;Warning, trying to clean up when anon queue not empty!&#34;)
        if self.cacheQueue.empty() != True:
            logging.warning(&#34;Warning, trying to clean up when cache queue not empty!&#34;)
        # Stuff in end signals for the workers (this is a bit bogus, cause
        # if a thread is gone or hanging, not all signals will get read)
        for i in range(self._p[&#39;numRawDbThreads&#39;]):
            self._rawQ.put(None)
        for i in range(self._p[&#39;numAnonDbThreads&#39;]):
            self._anonQ.put(None)

        for i in range(self.cacheQueue.qsize()):
            self.cacheQueue.put(None)

        cleanBgThreads()

        if len(self._p[&#39;pubDb&#39;]) &gt; 0:
            if self._pubQ.empty() != True:
                print(&#34;Warning, trying to clean up when pub queue not empty!&#34;)
            for i in range(self._p[&#39;numPubDbThreads&#39;]):
                self._pubQ.put(None)
            for t in self._pubThreads:
                if t.isAlive(): t.stop() # t.join()
        if cleanUpCache:
            self._removeLocalCacheDB()
        if doExit:
            sys.exit(exitMsg)

    def isClaimed(self, spec):
        &#34;&#34;&#34;Check if a claim was already fully or partially made.

        The `spec` is formatted identical to the `spec` in `gdaAttack.askClaim`.&#34;&#34;&#34;
        return self._dupCheck.is_claimed(spec, verbose=self._vb)

    def askClaim(self, spec, cache=True, claim=True):
        &#34;&#34;&#34;Generate Claim query for raw and optionally pub databases.

        Before anything happens, the system uses the `gdaAttack.isClaimed`
        method to determine whether a previous claim fully or partially
        matches the new claim. Such duplicates are not allowed and an error
        will be raised providing additional details about the duplicate.

        Making a claim results in a query to the raw database, and if
        linkability attack, the pub database, to check
        the correctness of the claim. Multiple calls to this method will
        cause the corresponding queries to be queued up, so `askClaim()`
        returns immediately. `getClaim()` harvests one claim result. &lt;br/&gt;
        Set `claim=False` if this claim should not be applied to the
        confidence improvement score. In this case, the probability score
        will instead be reduced accordingly. &lt;br/&gt;
        The `spec` is formatted as follows: &lt;br/&gt;

            {&#39;known&#39;:[{&#39;col&#39;:&#39;colName&#39;,&#39;val&#39;:&#39;value&#39;},...],
              &#39;guess&#39;:[{&#39;col&#39;:&#39;colName&#39;,&#39;val&#39;:&#39;value&#39;},...],
            }

        `spec[&#39;known&#39;]` are the columns and values the attacker already knows
        (i.e. with prior knowledge). Optional. &lt;br/&gt;
        `spec[&#39;guess&#39;]` are the columns and values the attacker doesn&#39;t know,
        but rather is trying to predict. Mandatory for &#39;singling out&#39;
        and &#39;inference&#39;. Optional for &#39;linkabiblity&#39; &lt;br/&gt;
        Answers are cached &lt;br/&gt;
        Returns immediately&#34;&#34;&#34;
        if self._vb: print(f&#34;Calling {__name__}.askClaim with spec &#39;{spec}&#39;, count {self._claimCounter}&#34;)
        if not self._dupCheck.is_claimed(spec, verbose=self._vb, raise_true=True):
            self._dupCheck.claim(spec, verbose=self._vb)
        self._claimCounter += 1
        sql = self._makeSqlFromSpec(spec)
        if self._vb: print(f&#34;Sql is &#39;{sql}&#39;&#34;)
        sqlConfs = self._makeSqlConfFromSpec(spec)
        if self._vb: print(f&#34;SqlConf is &#39;{sqlConfs}&#39;&#34;)
        # Make a copy of the query for passing around
        job = {}
        job[&#39;q&#39;] = self._claimQ
        job[&#39;claim&#39;] = claim
        job[&#39;queries&#39;] = [{&#39;sql&#39;: sql, &#39;cache&#39;: cache}]
        job[&#39;spec&#39;] = spec
        for sqlConf in sqlConfs:
            job[&#39;queries&#39;].append({&#39;sql&#39;: sqlConf, &#39;cache&#39;: cache})
        self._rawQ.put(job)

    def getClaim(self):
        &#34;&#34;&#34; Wait for and gather results of askClaim() calls

            Returns a data structure that contains both the result
            of one finished claim, and the claim&#39;s input parameters.
            Note that the order in which results are returned by
            `getClaim()` are not necessarily the same order they were
            inserted by `askClaim()`. &lt;br/&gt;
            Assuming `result` is returned: &lt;br/&gt;
            `result[&#39;claim&#39;]` is the value supplied in the corresponding
            `askClaim()` call &lt;br/&gt;
            `result[&#39;spec&#39;]` is a copy of the `spec` supplied in the
            corresponding `askClaim()` call. &lt;br/&gt;
            `result[&#39;queries&#39;]` is a list of the queries generated in order to
            validate the claim. &lt;br/&gt;
            `result[&#39;answers&#39;]` are the answers to the queries in
            `result[&#39;queries&#39;]`. &lt;br/&gt;
            `result[&#39;claimResult&#39;]` is &#39;Correct&#39; or &#39;Incorrect&#39;, depending
            on whether the claim satisfies the critieria or not. &lt;br/&gt;
            `result[&#39;stillToCome&#39;]` is a counter showing how many more
            claims are still queued. When `stillToCome` is 0, then all
            claims submitted by `askClaim()` have been returned.&#34;&#34;&#34;

        if self._vb:
            print(f&#34;Calling {__name__}.getClaim&#34;)
        if self._claimCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0, &#39;claimResult&#39;: &#39;Error&#39;}
        job = self._claimQ.get()
        claim = job[&#39;claim&#39;]
        self._claimQ.task_done()
        self._claimCounter -= 1
        job[&#39;stillToCome&#39;] = self._claimCounter
        self._addToAtkRes(&#39;claimTrials&#39;, job[&#39;spec&#39;], 1)
        # The claim is tested against the first reply
        reply = job[&#39;replies&#39;][0]
        job[&#39;claimResult&#39;] = &#39;Wrong&#39;
        if claim:
            self._addToAtkRes(&#39;claimMade&#39;, job[&#39;spec&#39;], 1)
        if &#39;error&#39; in reply:
            self._addToAtkRes(&#39;claimError&#39;, job[&#39;spec&#39;], 1)
            job[&#39;claimResult&#39;] = &#39;Error&#39;
        else:
            if self._cr == &#39;singlingOut&#39;:
                claimIsCorrect = self._checkSinglingOut(reply[&#39;answer&#39;])
            elif self._cr == &#39;inference&#39;:
                claimIsCorrect = self._checkInference(reply[&#39;answer&#39;])
            elif self._cr == &#39;linkability&#39;:
                claimIsCorrect = self._checkLinkability(reply[&#39;answer&#39;])
            if claim == 1 and claimIsCorrect:
                self._addToAtkRes(&#39;claimCorrect&#39;, job[&#39;spec&#39;], 1)
                job[&#39;claimResult&#39;] = &#39;Correct&#39;
            elif claim == 0 and claimIsCorrect:
                self._addToAtkRes(&#39;claimPassCorrect&#39;, job[&#39;spec&#39;], 1)
                job[&#39;claimResult&#39;] = &#39;Correct&#39;
        if self._cr == &#39;singlingOut&#39; or self._cr == &#39;inference&#39;:
            # Then measure confidence against the second and third replies
            if &#39;answer&#39; in job[&#39;replies&#39;][1]:
                if job[&#39;replies&#39;][1][&#39;answer&#39;]:
                    guessedRows = job[&#39;replies&#39;][1][&#39;answer&#39;][0][0]
                else:
                    guessedRows = 0
            elif &#39;error&#39; in job[&#39;replies&#39;][1]:
                self._pp.pprint(job)
                print(f&#34;Error: conf query:\n{job[&#39;replies&#39;][1][&#39;error&#39;]}&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if &#39;answer&#39; in job[&#39;replies&#39;][2]:
                if job[&#39;replies&#39;][2][&#39;answer&#39;]:
                    totalRows = job[&#39;replies&#39;][2][&#39;answer&#39;][0][0]
                else:
                    totalRows = 0
            elif &#39;error&#39; in job[&#39;replies&#39;][2]:
                self._pp.pprint(job)
                print(f&#34;Error: conf query:\n{job[&#39;replies&#39;][2][&#39;error&#39;]}&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if totalRows:
                self._addToAtkRes(&#39;sumConfidenceRatios&#39;, job[&#39;spec&#39;],
                                  guessedRows / totalRows)
                self._addToAtkRes(&#39;numConfidenceRatios&#39;, job[&#39;spec&#39;], 1)
                self._atrs[&#39;tableStats&#39;][&#39;totalRows&#39;] = totalRows
        else:
            # For linkability, the confidence is always 1/2
            self._addToAtkRes(&#39;sumConfidenceRatios&#39;, job[&#39;spec&#39;], 0.5)
            self._addToAtkRes(&#39;numConfidenceRatios&#39;, job[&#39;spec&#39;], 1)
        if &#39;q&#39; in job:
            del job[&#39;q&#39;]
        return (job)

    def askAttack(self, query, cache=True):
        &#34;&#34;&#34; Generate and queue up an attack query for database.

            `query` is a dictionary with (currently) one value: &lt;br/&gt;
            `query[&#39;sql&#39;] contains the SQL query.&#34;&#34;&#34;
        self._attackCounter += 1
        if self._vb: print(f&#34;Calling {__name__}.askAttack with query &#39;{query}&#39;, count {self._attackCounter}&#34;)
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job[&#39;q&#39;] = self._attackQ
        qCopy[&#39;cache&#39;] = cache
        job[&#39;queries&#39;] = [qCopy]
        self._anonQ.put(job)

    def getAttack(self):
        &#34;&#34;&#34; Returns the result of one askAttack() call

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askAttack()` calls were made. &lt;br/&gt;
            Assuming `result` is returned: &lt;br/&gt;
            `result[&#39;answer&#39;]` is the answer returned by the DB. The
            format is: &lt;br/&gt;
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` &lt;br/&gt;
            where C1 is the first element of the `SELECT`, C2 the second
            element, etc. &lt;br/&gt;
            `result[&#39;cells&#39;]` is the number of cells returned in the answer
            (used by `gdaAttack()` to compute total attack cells) &lt;br/&gt;
            `result[&#39;query&#39;][&#39;sql&#39;]` is the query from the corresponding
            `askAttack()`.&#34;&#34;&#34;

        if self._vb:
            print(f&#34;Calling {__name__}.getAttack&#34;)
        if self._attackCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0}
        job = self._attackQ.get()
        self._attackQ.task_done()
        self._attackCounter -= 1
        reply = job[&#39;replies&#39;][0]
        reply[&#39;stillToCome&#39;] = self._attackCounter
        self._atrs[&#39;base&#39;][&#39;attackGets&#39;] += 1
        if &#39;cells&#39; in reply:
            if reply[&#39;cells&#39;] == 0:
                self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += 1
            else:
                self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += reply[&#39;cells&#39;]
        else:
            self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += 1
        return (reply)

    def askKnowledge(self, query, cache=True):
        &#34;&#34;&#34; Generate and queue up a prior knowledge query for database

            The class keeps track of how many prior knowledge cells were
            returned and uses this to compute a score. &lt;br/&gt;
            Input parameters formatted the same as with `askAttack()`&#34;&#34;&#34;

        self._knowledgeCounter += 1
        if self._vb: print(f&#34;Calling {__name__}.askKnowledge with query &#34;
                           f&#34;&#39;{query}&#39;, count {self._knowledgeCounter}&#34;)
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job[&#39;q&#39;] = self._knowledgeQ
        qCopy[&#39;cache&#39;] = cache
        job[&#39;queries&#39;] = [qCopy]
        self._rawQ.put(job)

    def getKnowledge(self):
        &#34;&#34;&#34; Wait for and gather results of prior askKnowledge() calls

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askKnowledge()` calls were made. &lt;br/&gt;
            Return parameter formatted the same as with `getAttack()`&#34;&#34;&#34;

        if self._vb:
            print(f&#34;Calling {__name__}.getKnowledge&#34;)
        if self._knowledgeCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0}
        job = self._knowledgeQ.get()
        self._knowledgeQ.task_done()
        self._knowledgeCounter -= 1
        reply = job[&#39;replies&#39;][0]
        reply[&#39;stillToCome&#39;] = self._knowledgeCounter
        self._atrs[&#39;base&#39;][&#39;knowledgeGets&#39;] += 1
        if &#39;cells&#39; in reply:
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += reply[&#39;cells&#39;]
        return (reply)

    def askExplore(self, query, cache=True):
        &#34;&#34;&#34; Generate and queue up an exploritory query for database

            No score book-keeping is done here. An analyst may make
            any number of queries without impacting the GDA score. &lt;br/&gt;
            `query` is a dictionary with two values: &lt;br/&gt;
            `query[&#39;sql&#39;]` contains the SQL query. &lt;br/&gt;
            `query[&#39;db&#39;]` determines which database is queried, and
            is one of &#39;rawDb&#39;, &#39;anonDb&#39;, or (if linkability), &#39;pubDb&#39;.&#34;&#34;&#34;

        self._exploreCounter += 1
        if self._vb: print(f&#34;Calling {__name__}.askExplore with &#34;
                           f&#34;query &#39;{query}&#39;, count {self._exploreCounter}&#34;)
        # Make a copy of the query for passing around
        qCopy = copy.copy(query)
        job = {}
        job[&#39;q&#39;] = self._exploreQ
        qCopy[&#39;cache&#39;] = cache
        job[&#39;queries&#39;] = [qCopy]
        if qCopy[&#39;db&#39;] == &#39;rawDb&#39; or qCopy[&#39;db&#39;] == &#39;raw&#39;:
            self._rawQ.put(job)
        elif qCopy[&#39;db&#39;] == &#39;anonDb&#39; or qCopy[&#39;db&#39;] == &#39;anon&#39;:
            self._anonQ.put(job)
        else:
            self._pubQ.put(job)

    def getExplore(self):
        &#34;&#34;&#34; Wait for and gather results of prior askExplore() calls.

            Blocks until the result is available. Note that the order
            in which results are received is not necesarily the order
            in which `askExplore()` calls were made. &lt;br/&gt;
            Return parameter formatted the same as with `getAttack()`&#34;&#34;&#34;
        if self._vb:
            print(f&#34;Calling {__name__}.getExplore&#34;)
        if self._exploreCounter == 0:
            # Caller shouldn&#39;t be calling if there are no expected
            # answers, but is anyway, so just return
            return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                    &#39;stillToCome&#39;: 0}
        job = self._exploreQ.get()
        self._exploreQ.task_done()
        self._exploreCounter -= 1
        reply = job[&#39;replies&#39;][0]
        reply[&#39;stillToCome&#39;] = self._exploreCounter
        return (reply)

    def getPublicColValues(self, colName, tableName=&#39;&#39;):
        &#34;&#34;&#34;Return list of &#34;publicly known&#34; column values and counts

        Column value has index 0, count of distinct UIDs has index 1
        Must specify column name.
        &#34;&#34;&#34;
        if len(colName) == 0:
            print(f&#34;Must specify column &#39;colName&#39;&#34;)
            return None

        if len(tableName) == 0:
            # caller didn&#39;t supply a table name, so get it from the
            # class init
            tableName = self._p[&#39;table&#39;]

        # Establish connection to database
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # First we need to know the total number of distinct users
        sql = str(f&#34;&#34;&#34;select count(distinct {self._p[&#39;uid&#39;]})
                      from {tableName}&#34;&#34;&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        numUid = ans[0][0]
        # Query the raw db for values in the column
        sql = str(f&#34;&#34;&#34;select {colName}, count(distinct {self._p[&#39;uid&#39;]})
                      from {tableName}
                      group by 1
                      order by 2 desc
                      limit 200&#34;&#34;&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            # row[0] is the value, row[1] is the count
            if (((row[1] / numUid) &gt; 0.002) and
                    (row[1] &gt;= 50)):
                ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getColNames(self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;):
        &#34;&#34;&#34;Return simple list of column names

        `dbType` is one of &#39;rawDb&#39; or &#39;anonDb&#39;&#34;&#34;&#34;

        if len(tableName) == 0:
            colsAndTypes = self.getColNamesAndTypes(dbType=dbType)
        else:
            colsAndTypes = self.getColNamesAndTypes(
                dbType=dbType, tableName=tableName)
        if not colsAndTypes:
            return None
        cols = []
        for tup in colsAndTypes:
            cols.append(tup[0])
        return cols

    def getAttackTableName(self):
        &#34;&#34;&#34;Returns the name of the table being used in the attack.&#34;&#34;&#34;
        return self._p[&#39;table&#39;]

    def getTableCharacteristics(self, tableName=&#39;&#39;):
        &#34;&#34;&#34;Returns the full contents of the table characteristics

           Return value is a dict indexed by column name: &lt;br/&gt;

               { &#39;&lt;colName&gt;&#39;:
                   {
                       &#39;av_rows_per_vals&#39;: 3.93149,
                       &#39;av_uids_per_val&#39;: 0.468698,
                       &#39;column_label&#39;: &#39;continuous&#39;,
                       &#39;column_name&#39;: &#39;dropoff_latitude&#39;,
                       &#39;column_type&#39;: &#39;real&#39;,
                       &#39;max&#39;: &#39;898.29382000000000&#39;,
                       &#39;min&#39;: &#39;-0.56333297000000&#39;,
                       &#39;num_distinct_vals&#39;: 24216,
                       &#39;num_rows&#39;: 95205,
                       &#39;num_uids&#39;: 11350,
                       &#39;std_rows_per_val&#39;: 10.8547,
                       &#39;std_uids_per_val&#39;: 4.09688},
                   }
               }

        &#34;&#34;&#34;
        if len(tableName) == 0:
            # caller didn&#39;t supply a table name, so get it from the
            # class init
            tableName = self._p[&#39;table&#39;]

        # Modify table name to the default for the characteristics table
        tableName += &#39;_char&#39;

        # Establish connection to database
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Set up return dict
        ret = {}
        # Query it for column names
        sql = str(f&#34;&#34;&#34;select column_name, data_type 
                  from information_schema.columns where
                  table_name=&#39;{tableName}&#39;&#34;&#34;&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getTableCharacteristics() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        cols = cur.fetchall()
        # Make index for column name (should be 0, but just to be sure)
        for colNameIndex in range(len(cols)):
            if cols[colNameIndex][0] == &#39;column_name&#39;:
                break

        # Query it for table contents
        sql = str(f&#34;SELECT * FROM {tableName}&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getTableCharacteristics() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        for row in ans:
            colName = row[colNameIndex]
            ret[colName] = {}
            for i in range(len(row)):
                ret[colName][cols[i][0]] = row[i]
        conn.close()
        return ret

    # Note that following is used internally, but we expose it to the
    # caller as well because it is a useful function for exploration
    def getColNamesAndTypes(self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;):
        &#34;&#34;&#34;Return raw database column names and types (or None if error)

        dbType is one of &#39;rawDb&#39; or &#39;anonDb&#39; &lt;br/&gt;
        return format: [(col,type),(col,type),...]&#34;&#34;&#34;
        if len(tableName) == 0:
            # caller didn&#39;t supply a table name, so get it from the
            # class init
            tableName = self._p[&#39;table&#39;]

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db[&#39;type&#39;] != &#39;postgres&#39; and db[&#39;type&#39;] != &#39;aircloak&#39;:
            print(f&#34;DB type &#39;{db[&#39;type&#39;]}&#39; must be &#39;postgres&#39; or &#39;aircloak&#39;&#34;)
            return None
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db[&#39;type&#39;] == &#39;postgres&#39;:
            sql = str(f&#34;&#34;&#34;select column_name, data_type 
                      from information_schema.columns where
                      table_name=&#39;{tableName}&#39;&#34;&#34;&#34;)
        elif db[&#39;type&#39;] == &#39;aircloak&#39;:
            sql = str(f&#34;show columns from {tableName}&#34;)
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getColNamesAndTypes() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append((row[0], row[1]))
        conn.close()
        return ret

    def getTableNames(self, dbType=&#39;rawDb&#39;):
        &#34;&#34;&#34;Return database table names

        dbType is one of &#39;rawDb&#39; or &#39;anonDb&#39; &lt;br/&gt;
        Table names returned as list, unless error then return None&#34;&#34;&#34;

        # Establish connection to database
        db = getDatabaseInfo(self._p[dbType])
        if db[&#39;type&#39;] != &#39;postgres&#39; and db[&#39;type&#39;] != &#39;aircloak&#39;:
            print(f&#34;DB type &#39;{db[&#39;type&#39;]}&#39; must be &#39;postgres&#39; or &#39;aircloak&#39;&#34;)
            return None
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Query it for column names
        if db[&#39;type&#39;] == &#39;postgres&#39;:
            sql = &#34;&#34;&#34;SELECT tablename
                     FROM pg_catalog.pg_tables
                     WHERE schemaname != &#39;pg_catalog&#39; AND
                           schemaname != &#39;information_schema&#39;&#34;&#34;&#34;
        elif db[&#39;type&#39;] == &#39;aircloak&#39;:
            sql = &#34;show tables&#34;
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getTableNames() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        ret = []
        for row in ans:
            ret.append(row[0])
        conn.close()
        return ret

    def getUidColName(self):
        &#34;&#34;&#34; Returns the name of the UID column&#34;&#34;&#34;
        return self._p[&#39;uid&#39;]

    def getPriorKnowledge(self, dataColumns, method,
            fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):
        &#34;&#34;&#34; Returns data from the rawDB according to a specification

        This mimics external knowledge that an attacker may have about the data, and
        influences the &#39;knowledge&#39; part of the GDA Score. &lt;br/&gt;
            `dataColumns` is a list of column names. The data for these columns is returned &lt;br/&gt;
            `method` can be &#39;rows&#39; or &#39;users&#39;. If &#39;rows&#39;, then rows are selected
            according to the criteria (`fraction`, `count`, `selectColumn`, `colRange`,
            or `values`).
            If &#39;users&#39;, then all rows for a set of selected users is returned.
            The users are selected according to the criteria (`fraction` or `count`) &lt;br/&gt;
            If none of the criteria are set, or if `fraction` is set to 1.0, then all
            rows are returned (for the selected column values) One of `fraction`, `count`,
            or `selectColumn` must be set. &lt;br/&gt;
            `fraction` or `count` are set to obtain a random set of rows or users. If
            `fraction`, then an approximate fraction of all rows/users is selected.
            `fraction` is a value between 0 and 1.0. If `count`, then exactly `count`
            random rows/users are selected. &lt;br/&gt;
            `selectColumn` is set to select rows according to the values of the specified
            column. `selectColumn` is a column name. If set, then either a range of
            values (`colRange`), or a set of values (`values`) must be chosen. &lt;br/&gt;
            `colRange` is
            a list with two values: `[min,max]`. This selects all values
            between min and max inclusive. &lt;br/&gt;
            `values` is a list
            of one or more values of any type. This selects all values matching those in
            the list. &lt;br/&gt;
            The return value is a list in this format: &lt;br/&gt;
                `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` &lt;br/&gt;
            where C1 corresponds to the first column in `dataColumns`, C2 corresponds to
            the second column in `dataColumns`, and so on.  &lt;br/&gt;
        &#34;&#34;&#34;
        # Check input parameters
        if not isinstance(dataColumns, list):
            print(f&#34;getPriorKnowledge Error: dataColumns must be a list of one or more column names&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if method not in [&#39;rows&#39;,&#39;users&#39;]:
            print(f&#34;getPriorKnowledge Error: method must be &#39;rows&#39; or &#39;users&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction is None and count is None and selectColumn is None:
            print(f&#34;getPriorKnowledge Error: one of fraction, count, or selectColumn must be set&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if fraction and not isinstance(fraction, float):
            print(f&#34;getPriorKnowledge Error: if set, fraction must be a float&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if (fraction and (count or selectColumn)) or (count and (fraction or selectColumn)):
            print(f&#34;getPriorKnowledge Error: only one of fraction, count, or selectColumn may be set&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if count and not isinstance(count, int):
            print(f&#34;getPriorKnowledge Error: if set, count must be an integer&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if selectColumn:
            if selectColumn not in self._colNames:
                print(f&#34;getPriorKnowledge Error: selectColumn &#39;{selectColumn}&#39; is not a valid column&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if colRange == [None,None] and values == [None]:
                print(f&#34;getPriorKnowledge Error: if selectColumn is set, one of colRange or values must be set&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not isinstance(colRange, list):
                print(f&#34;getPriorKnowledge Error: colRange must be a list with two values&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if not (isinstance(values, list) or isinstance(values, tuple)) or len(values) == 0:
                print(f&#34;getPriorKnowledge Error: values must be a list or tuple with one or more values&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
        for col in dataColumns:
            if col not in self._colNames:
                print(f&#34;getPriorKnowledge Error: column &#39;{col}&#39; is not a valid column&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
        # Basic input checks finished
        # Establish connection to database
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        connStr = str(
            f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        table = self._p[&#39;table&#39;]
        uid = self._p[&#39;uid&#39;]
        # Make the SELECT part of the SQL query
        initSql = &#39;SELECT &#39;
        for col in dataColumns:
            initSql += str(f&#34;{col}, &#34;)
        initSql = initSql[0:-2]
        if method == &#39;rows&#39; and fraction:
            sql = initSql + str(f&#34; FROM {table} WHERE random() &lt;= {fraction}&#34;)
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;users&#39; and fraction:
            sql = initSql + str(f&#34; FROM {table} WHERE {uid} IN &#34;)
            sql += str(f&#34;(SELECT {uid} from (SELECT DISTINCT {uid} FROM {table}) t WHERE random() &lt; {fraction})&#34;)
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;rows&#39; and colRange[0] is not None:
            for pair in self._colNamesTypes:
                if selectColumn in pair[0]:
                    colType = pair[1]
                    break
            if &#39;text&#39; in colType or &#39;char&#39; in colType or &#39;date&#39; in colType or &#39;time&#39; in colType:
                sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} &gt;= &#39;{colRange[0]}&#39; and {selectColumn} &lt;= &#39;{colRange[1]}&#39;&#34;)
            else:
                sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} &gt;= {colRange[0]} and {selectColumn} &lt;= {colRange[1]}&#34;)
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;rows&#39; and values[0] is not None:
            sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} IN (&#34;)
            for pair in self._colNamesTypes:
                if selectColumn in pair[0]:
                    colType = pair[1]
                    break
            for value in values:
                if &#34;text&#34; in colType or &#34;date&#34; in colType or &#34;time&#34; in colType:
                    sql += str(f&#34;&#39;{value}&#39;, &#34;)
                else:
                    sql += str(f&#34;{value}, &#34;)
            sql = sql[0:-2]
            sql += &#34;)&#34;
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;rows&#39; and count:
            # need to know the total number of rows
            sql = str(f&#34;select count(*) from {table}&#34;)
            ans = self._doQuery(cur,sql)
            numRows = ans[0][0]
            # next we get some random set of rows that is certainly more than we need
            frac = (count/numRows)*2
            sql = initSql + str(f&#34; FROM {table} WHERE random() &lt;= {frac}&#34;)
            temp = self._doQuery(cur,sql)
            # next we scramble these so that we get a random sampling from the random sampling
            random.shuffle(temp)
            # finally pick the exact count
            ans = temp[0:count]
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        if method == &#39;users&#39; and count:
            # get the full list of distinct UIDs
            sql = str(f&#34;SELECT DISTINCT {uid} from {table}&#34;)
            uidList = self._doQuery(cur,sql)
            # next we scramble these so that we can get a random sampling
            random.shuffle(uidList)
            # pick the exact count of UIDs
            uidList = uidList[0:count]
            sql = initSql + str(f&#34; FROM {table} WHERE {uid} IN (&#34;)
            for pair in self._colNamesTypes:
                if uid in pair[0]:
                    colType = pair[1]
                    break
            for uidVal in uidList:
                if &#34;text&#34; in colType or &#34;date&#34; in colType or &#34;time&#34; in colType:
                    sql += str(f&#34;&#39;{uidVal[0]}&#39;, &#34;)
                else:
                    sql += str(f&#34;{uidVal[0]}, &#34;)
            sql = sql[0:-2]
            sql += &#34;)&#34;
            ans = self._doQuery(cur,sql)
            self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
            return(ans)
        #zzzz
        return None
    #def getPriorKnowledge(self, dataColumns, method,
            #fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):

    # -------------- Private Methods -------------------
    def _doQuery(self,cur,sql):
        try:
            cur.execute(sql)
        except psycopg2.Error as e:
            print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        ans = cur.fetchall()
        return ans

    def _cleanPasswords(self):
        if &#39;attack&#39; in self._atrs:
            if (&#39;anonDb&#39; in self._atrs[&#39;attack&#39;] and
                    &#39;password&#39; in self._atrs[&#39;attack&#39;][&#39;anonDb&#39;]):
                self._atrs[&#39;attack&#39;][&#39;anonDb&#39;][&#39;password&#39;] = &#39;xxxxxxx&#39;
            if (&#39;rawDb&#39; in self._atrs[&#39;attack&#39;] and
                    &#39;password&#39; in self._atrs[&#39;attack&#39;][&#39;rawDb&#39;]):
                self._atrs[&#39;attack&#39;][&#39;rawDb&#39;][&#39;password&#39;] = &#39;xxxxxxx&#39;
            if (&#39;pubDb&#39; in self._atrs[&#39;attack&#39;] and
                    &#39;password&#39; in self._atrs[&#39;attack&#39;][&#39;pubDb&#39;]):
                self._atrs[&#39;attack&#39;][&#39;pubDb&#39;][&#39;password&#39;] = &#39;xxxxxxx&#39;

        return

    def _assignGlobalParams(self, params):
        self._pp = pprint.PrettyPrinter(indent=4)
        for key, val in params.items():
            self._p[key] = val
            # assign verbose value to a smaller variable name
            if key == &#34;verbose&#34;:
                if val != False:
                    self._vb = True
            # Check criteria
            if key == &#34;criteria&#34;:
                if (val == &#39;singlingOut&#39; or val == &#39;inference&#39; or
                        val == &#39;linkability&#39;):
                    self._cr = val
                else:
                    print(&#34;&#34;&#34;Error: criteria must be one of &#39;singlingOut&#39;,
                             &#39;inference&#39;, or &#39;linkability&#39;&#34;&#34;&#34;)
                    sys.exit(&#39;&#39;)

    def _setupLocalCacheDB(self):
        path = self._p[&#39;locCacheDir&#39;] + &#34;/&#34; + self._p[&#39;name&#39;] + &#34;.db&#34;
        conn = sqlite3.connect(path)
        cur = conn.cursor()
        if self._p[&#39;flushCache&#39;] == True:
            sql = &#34;DROP TABLE IF EXISTS tab&#34;
            if self._vb: print(f&#34;   cache DB: {sql}&#34;)
            cur.execute(sql)
        sql = &#34;&#34;&#34;CREATE TABLE IF NOT EXISTS tab
                 (qid text, answer text)&#34;&#34;&#34;
        if self._vb: print(f&#34;   cache DB: {sql}&#34;)
        cur.execute(sql)
        conn.close()

    def _removeLocalCacheDB(self):
        path = self._p[&#39;locCacheDir&#39;] + &#34;/&#34; + self._p[&#39;name&#39;] + &#34;.db&#34;
        max_attempts = 5
        attempt = 0
        removeFlag = False
        _ex = None
        if os.path.exists(path):
            while attempt &lt;= max_attempts:
                attempt += 1
                try:
                    os.remove(path)
                    removeFlag = True
                    break
                except Exception as ex:
                    _ex = ex
                    removeFlag = False
                time.sleep(0.3)

            if not removeFlag:
                logging.error(f&#34;cache db removing error after {attempt} attempts.\n&#34;
                              f&#34;ERROR: Failed to remove cache DB {path} =&gt; ex: {_ex}&#34;)
            else:
                logging.info(f&#34;cache db removed successfully after {attempt} attempt(s).&#34;)

    def removeLocalCacheDBWrapper(self):
        return self._removeLocalCacheDB()

    def _setupThreadsAndQueues(self):
        self._anonThreads = []
        self._rawThreads = []
        self._pubThreads = []
        self._exploreQ = queue.Queue()
        self._knowledgeQ = queue.Queue()
        self._attackQ = queue.Queue()
        self._claimQ = queue.Queue()
        self._guessQ = queue.Queue()
        self._rawQ = queue.Queue()
        if self._cr == &#39;linkability&#39;:
            self._pubQ = queue.Queue()
        self._anonQ = queue.Queue()
        backQ = queue.Queue()
        for i in range(self._p[&#39;numRawDbThreads&#39;]):
            d = dict(db=self._p[&#39;rawDb&#39;], q=self._rawQ,
                     kind=&#39;raw&#39;, backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._rawThreads.append(t)
        for i in range(self._p[&#39;numAnonDbThreads&#39;]):
            d = dict(db=self._p[&#39;anonDb&#39;], q=self._anonQ,
                     kind=&#39;anon&#39;, backQ=backQ)
            t = EnhancedThread(target=self._dbWorker, kwargs=d)
            t.start()
            self._anonThreads.append(t)
        if self._cr == &#39;linkability&#39;:
            for i in range(self._p[&#39;numPubDbThreads&#39;]):
                d = dict(db=self._p[&#39;pubDb&#39;], q=self._pubQ,
                         kind=&#39;pub&#39;, backQ=backQ)
                t = EnhancedThread(target=self._dbWorker, kwargs=d)
                t.start()
                self._pubThreads.append(t)
        num = (self._p[&#39;numRawDbThreads&#39;] + self._p[&#39;numAnonDbThreads&#39;])
        if self._cr == &#39;linkability&#39;:
            num += self._p[&#39;numPubDbThreads&#39;]
        # Make sure all the worker threads are ready
        for i in range(num):
            msg = backQ.get()
            if self._vb: print(f&#34;{msg} is ready&#34;)
            backQ.task_done()

    def _dbWorker(self, db, q, kind, backQ):
        if self._vb: print(f&#34;Starting {__name__}.dbWorker:{db, kind}&#34;)
        me = threading.current_thread()
        d = getDatabaseInfo(db)
        # Establish connection to database
        connStr = str(
            f&#34;host={d[&#39;host&#39;]} port={d[&#39;port&#39;]} dbname={d[&#39;dbname&#39;]} user={d[&#39;user&#39;]} password={d[&#39;password&#39;]}&#34;)
        if self._vb: print(f&#34;    {me}: Connect to DB with DSN &#39;{connStr}&#39;&#34;)
        conn = psycopg2.connect(connStr)
        cur = conn.cursor()
        # Establish connection to local cache
        path = self._p[&#39;locCacheDir&#39;] + &#34;/&#34; + self._p[&#39;name&#39;] + &#34;.db&#34;
        # Set timeout low so that we don&#39;t spend a lot of time inserting
        # into the cache in case it gets overloaded
        connInsert = sqlite3.connect(path, timeout=0.1)
        curInsert = connInsert.cursor()
        connRead = sqlite3.connect(path)
        curRead = connRead.cursor()
        backQ.put(me)
        while True:
            if isinstance(me, EnhancedThread) and me.stopped():
                logging.info(f&#39; &gt; {me.getName()} stopped.&#39;)
                return
            try:
                jobOrig = q.get(block=True, timeout=3)
            except queue.Empty:
                continue
            q.task_done()
            if jobOrig is None:
                if self._vb: print(f&#34;    {me}: dbWorker done {db, kind}&#34;)
                conn.close()
                connRead.close()
                connInsert.close()
                break
            # make a copy for passing around
            job = copy.copy(jobOrig)
            replyQ = job[&#39;q&#39;]
            replies = []
            for query in job[&#39;queries&#39;]:
                reply = self._processQuery(query, conn, cur,
                                           connInsert, curInsert, curRead)
                replies.append(reply)
            job[&#39;replies&#39;] = replies
            replyQ.put(job)

    def _processQuery(self, query, conn, cur, connInsert, curInsert, curRead):
        # record and remove the return queue
        cache = query[&#39;cache&#39;]
        del query[&#39;cache&#39;]
        # Check the cache for the answer
        # Note that at this point query is a dict
        # containing the sql, the db (raw, anon, or pub),
        # and any tags that the source added
        cachedReply = None
        if cache:
            cachedReply = self._getCache(curRead, query)
        if cachedReply:
            if self._vb: print(&#34;    Answer from cache&#34;)
            if &#39;answer&#39; in cachedReply:
                numCells = self._computeNumCells(cachedReply[&#39;answer&#39;])
                cachedReply[&#39;cells&#39;] = numCells
            return cachedReply
        else:
            start = time.perf_counter()
            try:
                cur.execute(query[&#39;sql&#39;])
            except psycopg2.Error as e:
                reply = dict(error=e.pgerror)
            else:
                ans = cur.fetchall()
                numCells = self._computeNumCells(ans)
                reply = dict(answer=ans, cells=numCells)
            end = time.perf_counter()
            duration = end - start
            self._op[&#39;numQueries&#39;] += 1
            self._op[&#39;timeQueries&#39;] += duration
            reply[&#39;query&#39;] = query
            # only cache if the native query is slow
            if duration &gt; 0.1:
                # self._putCache(connInsert, curInsert, query, reply)
                self.cacheQueue.put([connInsert, curInsert, query, reply])
            return reply

    def _checkInference(self, ans):
        # column 0 must be UID
        # User is inferred if all users in answer have same attributes
        # Returns 1 if inference claim correct, else returns 0
        if len(ans) == 0:
            return 0
        numRows = len(ans)
        numColumns = len(ans[0])
        if numColumns &lt; 2:
            # Can&#39;t test inference unless there is at least one column
            # (other than UID) that is the same
            return 0
        for c in range(1, numColumns):
            val = ans[0][c]
            for r in range(1, numRows):
                if val != ans[r][c]:
                    return 0
        return 1

    def _checkLinkability(self, ans):
        # The test is the same as with singling out
        # Returns 1 if linkability claim correct, else returns 0
        return self._checkSinglingOut(ans)

    def _checkSinglingOut(self, ans):
        # column 0 must be UID
        # User is singled-out if there is only one distinct UID
        # Returns 1 if singling out claim correct, else returns 0
        if len(ans) == 0:
            return 0
        uids = {}
        for row in ans:
            uids[row[0]] = 1
        numUids = len(uids)
        if numUids == 1:
            return 1
        else:
            return 0

    def _computeNumCells(self, ans):
        # ans is a list of tuples [(x,y),(x,y),(x,y) ...
        # Count the number of columns (in the first row)
        if len(ans) == 0:
            return 0
        numColumns = len(ans[0])
        numRows = len(ans)
        numCells = numColumns * numRows
        return numCells

    def _doParamChecks(self):
        dbInfoRaw = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        if not dbInfoRaw:
            sys.exit(&#39;rawDb now found in database config&#39;)
        if len(self._p[&#39;anonDb&#39;]) == 0:
            self._p[&#39;anonDb&#39;] = self._p[&#39;rawDb&#39;]
        else:
            dbInfoAnon = getDatabaseInfo(self._p[&#39;anonDb&#39;])
            if not dbInfoAnon:
                sys.exit(&#39;anonDb not found in database config&#39;)
        if self._cr == &#39;linkability&#39;:
            dbInfo = getDatabaseInfo(self._p[&#39;pubDb&#39;])
            if not dbInfo:
                sys.exit(&#39;Must specify pubDb if criteria is linkability&#39;)
        numThreads = self._p[&#39;numRawDbThreads&#39;] + self._p[&#39;numAnonDbThreads&#39;]
        if self._cr == &#39;linkability&#39;:
            numThreads += self._p[&#39;numPubDbThreads&#39;]
        if numThreads &gt; 50:
            sys.exit(&#34;Error: Can&#39;t have more than 50 threads total&#34;)

    def _getCache(self, cur, query):
        # turn the query (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return None
        sql = str(f&#34;SELECT answer FROM tab where qid = &#39;{qStr}&#39;&#34;)
        if self._vb: print(f&#34;   cache DB: {sql}&#34;)
        start = time.perf_counter()
        try:
            cur.execute(sql)
        except sqlite3.Error as e:
            print(f&#34;getCache error &#39;{e.args[0]}&#39;&#34;)
            return None
        end = time.perf_counter()
        self._op[&#39;numCacheGets&#39;] += 1
        self._op[&#39;timeCacheGets&#39;] += (end - start)
        answer = cur.fetchone()
        if not answer:
            return None
        rtnDict = self._str2Dict(answer[0])
        return rtnDict

    def _putCache(self, conn, cur, query, reply):
        # turn the query and reply (dict) into a string
        qStr = self._dict2Str(query)
        if qStr is None:
            return
        rStr = self._dict2Str(reply)
        if rStr is None:
            return
        sql = str(f&#34;INSERT INTO tab VALUES (&#39;{qStr}&#39;,&#39;{rStr}&#39;)&#34;)
        if self._vb: print(f&#34;   cache DB: {sql}&#34;)
        start = time.perf_counter()
        err = None
        for z in range(10):
            try:
                cur.execute(sql)
                conn.commit()
            except sqlite3.OperationalError as e:
                if self._p[&#39;verbose&#39;] or self._vb:
                    print(f&#34;putCache error &#39;{e.args[0]}&#39;&#34;)
                err = e
                continue
            except sqlite3.Error as e:
                if self._p[&#39;verbose&#39;] or self._vb:
                    print(f&#34;putCache error &#39;{e.args[0]}&#39;&#34;)
                err = e
                continue
            else:
                break
        else:
            # raise err
            if self._p[&#39;verbose&#39;] or self._vb:
                print(f&#39;&gt;&gt; could not insert into cache DB &gt;&gt; ERROR: {err}&#39;)

        end = time.perf_counter()
        self._op[&#39;numCachePuts&#39;] += 1
        self._op[&#39;timeCachePuts&#39;] += (end - start)

    def putCacheWrapper(self, conn, cur, query, reply):
        self._putCache(conn, cur, query, reply)

    def _dict2Str(self, d):
        try:
            dStr = simplejson.dumps(d)
        except TypeError:
            print(&#34;simpleJson failed&#34;)
            return None
        dByte = str.encode(dStr)
        dByte64 = base64.b64encode(dByte)
        try:
            dByte64Str = str(dByte64, &#34;utf-8&#34;)
        except MemoryError:
            print(&#34;str(dByte64) failed&#34;)
            return None
        return dByte64Str

    def _str2Dict(self, dByte64Str):
        dByte64 = str.encode(dByte64Str)
        dByte = base64.b64decode(dByte64)
        dStr = str(dByte, &#34;utf-8&#34;)
        d = simplejson.loads(dStr)
        return d

    def _makeSqlFromSpec(self, spec):
        sql = &#34;select &#34;
        if &#39;known&#39; in spec:
            numKnown = len(spec[&#39;known&#39;])
        else:
            numKnown = 0
        if &#39;guess&#39; in spec:
            numGuess = len(spec[&#39;guess&#39;])
        else:
            numGuess = 0
        if self._cr == &#39;inference&#39;:
            sql += str(f&#34;{self._p[&#39;uid&#39;]}, &#34;)
            for i in range(numGuess):
                sql += str(f&#34;{spec[&#39;guess&#39;][i][&#39;col&#39;]}&#34;)
                if i == (numGuess - 1):
                    sql += &#34; &#34;
                else:
                    sql += &#34;, &#34;
            sql += str(f&#34;from {self._p[&#39;table&#39;]} &#34;)
            if numKnown:
                sql += &#34;where &#34;
            for i in range(numKnown):
                sql += str(f&#34;{spec[&#39;known&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;known&#39;][i][&#39;val&#39;]}&#39; &#34;)
                if i == (numKnown - 1):
                    sql += &#34; &#34;
                else:
                    sql += &#34;and &#34;
        elif self._cr == &#39;singlingOut&#39; or self._cr == &#39;linkability&#39;:
            sql += str(f&#34;{self._p[&#39;uid&#39;]} from {self._p[&#39;table&#39;]} where &#34;)
            for i in range(numKnown):
                sql += str(f&#34;{spec[&#39;known&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;known&#39;][i][&#39;val&#39;]}&#39; and &#34;)
            for i in range(numGuess):
                sql += str(f&#34;{spec[&#39;guess&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;guess&#39;][i][&#39;val&#39;]}&#39; &#34;)
                if i == (numGuess - 1):
                    sql += &#34; &#34;
                else:
                    sql += &#34;and &#34;
        return sql

    def _makeSqlConfFromSpec(self, spec):
        sqls = []
        numGuess = len(spec[&#39;guess&#39;])
        if self._cr == &#39;inference&#39; or self._cr == &#39;singlingOut&#39;:
            sql = str(f&#34;select count(distinct {self._p[&#39;uid&#39;]}) from {self._p[&#39;table&#39;]} where &#34;)
            # This first sql learns the number of rows matching the
            # guessed values
            for i in range(numGuess):
                sql += str(f&#34;{spec[&#39;guess&#39;][i][&#39;col&#39;]} = &#34;)
                sql += str(f&#34;&#39;{spec[&#39;guess&#39;][i][&#39;val&#39;]}&#39;&#34;)
                if i != (numGuess - 1):
                    sql += &#34; and &#34;
            sqls.append(sql)
            # This second sql learns the total number of rows (should
            # normally be a cached result)
            sql = str(f&#34;select count(distinct {self._p[&#39;uid&#39;]}) from {self._p[&#39;table&#39;]}&#34;)
            sqls.append(sql)
        elif self._cr == &#39;linkability&#39;:
            # nothing happens for linkability
            pass
        return sqls

    def _addToAtkRes(self, label, spec, val):
        &#34;&#34;&#34;Adds the value to each column in the guess&#34;&#34;&#34;
        for tup in spec[&#39;guess&#39;]:
            col = tup[&#39;col&#39;]
            if col not in self._atrs[&#39;col&#39;]:
                print(f&#34;Error: addToAtkRes(): Bad column in spec: &#39;{col}&#39;&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            if label not in self._atrs[&#39;col&#39;][col]:
                print(f&#34;Error: addToAtkRes(): Bad label &#39;{label}&#39;&#34;)
                self.cleanUp(cleanUpCache=False, doExit=True)
            self._atrs[&#39;col&#39;][col][label] += val

    def _initAtkRes(self):
        self._atrs = {}
        self._atrs[&#39;attack&#39;] = {}
        self._atrs[&#39;base&#39;] = {}
        self._atrs[&#39;tableStats&#39;] = {}
        self._atrs[&#39;col&#39;] = {}
        # ----- Attack parameters
        self._atrs[&#39;attack&#39;][&#39;attackName&#39;] = self._p[&#39;name&#39;]
        self._atrs[&#39;attack&#39;][&#39;rawDb&#39;] = self._p[&#39;rawDb&#39;]
        self._atrs[&#39;attack&#39;][&#39;anonDb&#39;] = self._p[&#39;anonDb&#39;]
        if self._cr == &#39;linkability&#39;:
            self._atrs[&#39;attack&#39;][&#39;pubDb&#39;] = self._p[&#39;anonDb&#39;]
        self._atrs[&#39;attack&#39;][&#39;criteria&#39;] = self._p[&#39;criteria&#39;]
        self._atrs[&#39;attack&#39;][&#39;table&#39;] = self._p[&#39;table&#39;]
        # add parameters for the database machine itself
        db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
        self._atrs[&#39;attack&#39;][&#39;rawHost&#39;] = db[&#39;host&#39;]
        self._atrs[&#39;attack&#39;][&#39;rawDbName&#39;] = db[&#39;dbname&#39;]
        self._atrs[&#39;attack&#39;][&#39;rawPort&#39;] = db[&#39;port&#39;]
        if self._cr == &#39;linkability&#39;:
            db = getDatabaseInfo(self._p[&#39;pubDb&#39;])
            self._atrs[&#39;attack&#39;][&#39;pubHost&#39;] = db[&#39;host&#39;]
            self._atrs[&#39;attack&#39;][&#39;pubDbName&#39;] = db[&#39;dbname&#39;]
            self._atrs[&#39;attack&#39;][&#39;pubPort&#39;] = db[&#39;port&#39;]
        db = getDatabaseInfo(self._p[&#39;anonDb&#39;])
        self._atrs[&#39;attack&#39;][&#39;anonHost&#39;] = db[&#39;host&#39;]
        self._atrs[&#39;attack&#39;][&#39;anonDbName&#39;] = db[&#39;dbname&#39;]
        self._atrs[&#39;attack&#39;][&#39;anonPort&#39;] = db[&#39;port&#39;]
        # and a timestamp
        self._atrs[&#39;attack&#39;][&#39;startTime&#39;] = str(datetime.datetime.now())
        # ----- Params for computing knowledge:
        # number of prior knowledge cells requested
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] = 0
        # number of times knowledge was queried
        self._atrs[&#39;base&#39;][&#39;knowledgeGets&#39;] = 0

        # ----- Params for computing how much work needed to attack:
        # number of attack cells requested
        self._atrs[&#39;base&#39;][&#39;attackCells&#39;] = 0
        # number of times attack was queried
        self._atrs[&#39;base&#39;][&#39;attackGets&#39;] = 0
        self._atrs[&#39;tableStats&#39;][&#39;colNamesAndTypes&#39;] = self._colNamesTypes
        self._atrs[&#39;tableStats&#39;][&#39;numColumns&#39;] = len(self._colNamesTypes)
        for tup in self._colNamesTypes:
            col = tup[0]
            if self._vb: print(f&#34;initAtkRes() init column &#39;{col}&#39;&#34;)
            self._atrs[&#39;col&#39;][col] = {}

            # ----- Params for computing claim success rate:
            # total possible number of claims
            self._atrs[&#39;col&#39;][col][&#39;claimTrials&#39;] = 0
            # actual number of claims
            self._atrs[&#39;col&#39;][col][&#39;claimMade&#39;] = 0
            # number of correct claims
            self._atrs[&#39;col&#39;][col][&#39;claimCorrect&#39;] = 0
            # number of claims that produced bad SQL answer
            self._atrs[&#39;col&#39;][col][&#39;claimError&#39;] = 0
            # claims where the attacker chose to pass (not make a claim),
            # but where the claim would have been correct
            self._atrs[&#39;col&#39;][col][&#39;claimPassCorrect&#39;] = 0

            # ----- Params for computing confidence:
            # sum of all known count to full count ratios
            self._atrs[&#39;col&#39;][col][&#39;sumConfidenceRatios&#39;] = 0
            # number of such ratios
            self._atrs[&#39;col&#39;][col][&#39;numConfidenceRatios&#39;] = 0
            # average confidence ratio (division of above two params)
            self._atrs[&#39;col&#39;][col][&#39;avgConfidenceRatios&#39;] = 0

    def _initOp(self):
        self._op[&#39;numQueries&#39;] = 0
        self._op[&#39;timeQueries&#39;] = 0
        self._op[&#39;numCachePuts&#39;] = 0
        self._op[&#39;timeCachePuts&#39;] = 0
        self._op[&#39;numCacheGets&#39;] = 0
        self._op[&#39;timeCacheGets&#39;] = 0

    def _initCounters(self):
        self._exploreCounter = 0
        self._knowledgeCounter = 0
        self._attackCounter = 0
        self._claimCounter = 0
        self._guessCounter = 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gdascore.gdaAttack.gdaAttack.askAttack"><code class="name flex">
<span>def <span class="ident">askAttack</span></span>(<span>self, query, cache=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and queue up an attack query for database.</p>
<p><code>query</code> is a dictionary with (currently) one value: <br/>
`query['sql'] contains the SQL query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askAttack(self, query, cache=True):
    &#34;&#34;&#34; Generate and queue up an attack query for database.

        `query` is a dictionary with (currently) one value: &lt;br/&gt;
        `query[&#39;sql&#39;] contains the SQL query.&#34;&#34;&#34;
    self._attackCounter += 1
    if self._vb: print(f&#34;Calling {__name__}.askAttack with query &#39;{query}&#39;, count {self._attackCounter}&#34;)
    # Make a copy of the query for passing around
    qCopy = copy.copy(query)
    job = {}
    job[&#39;q&#39;] = self._attackQ
    qCopy[&#39;cache&#39;] = cache
    job[&#39;queries&#39;] = [qCopy]
    self._anonQ.put(job)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.askClaim"><code class="name flex">
<span>def <span class="ident">askClaim</span></span>(<span>self, spec, cache=True, claim=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Claim query for raw and optionally pub databases.</p>
<p>Before anything happens, the system uses the <code><a title="gdascore.gdaAttack.gdaAttack.isClaimed" href="#gdascore.gdaAttack.gdaAttack.isClaimed">gdaAttack.isClaimed()</a></code>
method to determine whether a previous claim fully or partially
matches the new claim. Such duplicates are not allowed and an error
will be raised providing additional details about the duplicate.</p>
<p>Making a claim results in a query to the raw database, and if
linkability attack, the pub database, to check
the correctness of the claim. Multiple calls to this method will
cause the corresponding queries to be queued up, so <code>askClaim()</code>
returns immediately. <code>getClaim()</code> harvests one claim result. <br/>
Set <code>claim=False</code> if this claim should not be applied to the
confidence improvement score. In this case, the probability score
will instead be reduced accordingly. <br/>
The <code>spec</code> is formatted as follows: <br/></p>
<pre><code>{'known':[{'col':'colName','val':'value'},...],
  'guess':[{'col':'colName','val':'value'},...],
}
</code></pre>
<p><code>spec['known']</code> are the columns and values the attacker already knows
(i.e. with prior knowledge). Optional. <br/>
<code>spec['guess']</code> are the columns and values the attacker doesn't know,
but rather is trying to predict. Mandatory for 'singling out'
and 'inference'. Optional for 'linkabiblity' <br/>
Answers are cached <br/>
Returns immediately</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askClaim(self, spec, cache=True, claim=True):
    &#34;&#34;&#34;Generate Claim query for raw and optionally pub databases.

    Before anything happens, the system uses the `gdaAttack.isClaimed`
    method to determine whether a previous claim fully or partially
    matches the new claim. Such duplicates are not allowed and an error
    will be raised providing additional details about the duplicate.

    Making a claim results in a query to the raw database, and if
    linkability attack, the pub database, to check
    the correctness of the claim. Multiple calls to this method will
    cause the corresponding queries to be queued up, so `askClaim()`
    returns immediately. `getClaim()` harvests one claim result. &lt;br/&gt;
    Set `claim=False` if this claim should not be applied to the
    confidence improvement score. In this case, the probability score
    will instead be reduced accordingly. &lt;br/&gt;
    The `spec` is formatted as follows: &lt;br/&gt;

        {&#39;known&#39;:[{&#39;col&#39;:&#39;colName&#39;,&#39;val&#39;:&#39;value&#39;},...],
          &#39;guess&#39;:[{&#39;col&#39;:&#39;colName&#39;,&#39;val&#39;:&#39;value&#39;},...],
        }

    `spec[&#39;known&#39;]` are the columns and values the attacker already knows
    (i.e. with prior knowledge). Optional. &lt;br/&gt;
    `spec[&#39;guess&#39;]` are the columns and values the attacker doesn&#39;t know,
    but rather is trying to predict. Mandatory for &#39;singling out&#39;
    and &#39;inference&#39;. Optional for &#39;linkabiblity&#39; &lt;br/&gt;
    Answers are cached &lt;br/&gt;
    Returns immediately&#34;&#34;&#34;
    if self._vb: print(f&#34;Calling {__name__}.askClaim with spec &#39;{spec}&#39;, count {self._claimCounter}&#34;)
    if not self._dupCheck.is_claimed(spec, verbose=self._vb, raise_true=True):
        self._dupCheck.claim(spec, verbose=self._vb)
    self._claimCounter += 1
    sql = self._makeSqlFromSpec(spec)
    if self._vb: print(f&#34;Sql is &#39;{sql}&#39;&#34;)
    sqlConfs = self._makeSqlConfFromSpec(spec)
    if self._vb: print(f&#34;SqlConf is &#39;{sqlConfs}&#39;&#34;)
    # Make a copy of the query for passing around
    job = {}
    job[&#39;q&#39;] = self._claimQ
    job[&#39;claim&#39;] = claim
    job[&#39;queries&#39;] = [{&#39;sql&#39;: sql, &#39;cache&#39;: cache}]
    job[&#39;spec&#39;] = spec
    for sqlConf in sqlConfs:
        job[&#39;queries&#39;].append({&#39;sql&#39;: sqlConf, &#39;cache&#39;: cache})
    self._rawQ.put(job)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.askExplore"><code class="name flex">
<span>def <span class="ident">askExplore</span></span>(<span>self, query, cache=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and queue up an exploritory query for database</p>
<p>No score book-keeping is done here. An analyst may make
any number of queries without impacting the GDA score. <br/>
<code>query</code> is a dictionary with two values: <br/>
<code>query['sql']</code> contains the SQL query. <br/>
<code>query['db']</code> determines which database is queried, and
is one of 'rawDb', 'anonDb', or (if linkability), 'pubDb'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askExplore(self, query, cache=True):
    &#34;&#34;&#34; Generate and queue up an exploritory query for database

        No score book-keeping is done here. An analyst may make
        any number of queries without impacting the GDA score. &lt;br/&gt;
        `query` is a dictionary with two values: &lt;br/&gt;
        `query[&#39;sql&#39;]` contains the SQL query. &lt;br/&gt;
        `query[&#39;db&#39;]` determines which database is queried, and
        is one of &#39;rawDb&#39;, &#39;anonDb&#39;, or (if linkability), &#39;pubDb&#39;.&#34;&#34;&#34;

    self._exploreCounter += 1
    if self._vb: print(f&#34;Calling {__name__}.askExplore with &#34;
                       f&#34;query &#39;{query}&#39;, count {self._exploreCounter}&#34;)
    # Make a copy of the query for passing around
    qCopy = copy.copy(query)
    job = {}
    job[&#39;q&#39;] = self._exploreQ
    qCopy[&#39;cache&#39;] = cache
    job[&#39;queries&#39;] = [qCopy]
    if qCopy[&#39;db&#39;] == &#39;rawDb&#39; or qCopy[&#39;db&#39;] == &#39;raw&#39;:
        self._rawQ.put(job)
    elif qCopy[&#39;db&#39;] == &#39;anonDb&#39; or qCopy[&#39;db&#39;] == &#39;anon&#39;:
        self._anonQ.put(job)
    else:
        self._pubQ.put(job)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.askKnowledge"><code class="name flex">
<span>def <span class="ident">askKnowledge</span></span>(<span>self, query, cache=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate and queue up a prior knowledge query for database</p>
<p>The class keeps track of how many prior knowledge cells were
returned and uses this to compute a score. <br/>
Input parameters formatted the same as with <code>askAttack()</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def askKnowledge(self, query, cache=True):
    &#34;&#34;&#34; Generate and queue up a prior knowledge query for database

        The class keeps track of how many prior knowledge cells were
        returned and uses this to compute a score. &lt;br/&gt;
        Input parameters formatted the same as with `askAttack()`&#34;&#34;&#34;

    self._knowledgeCounter += 1
    if self._vb: print(f&#34;Calling {__name__}.askKnowledge with query &#34;
                       f&#34;&#39;{query}&#39;, count {self._knowledgeCounter}&#34;)
    # Make a copy of the query for passing around
    qCopy = copy.copy(query)
    job = {}
    job[&#39;q&#39;] = self._knowledgeQ
    qCopy[&#39;cache&#39;] = cache
    job[&#39;queries&#39;] = [qCopy]
    self._rawQ.put(job)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.cleanUp"><code class="name flex">
<span>def <span class="ident">cleanUp</span></span>(<span>self, cleanUpCache=True, doExit=False, exitMsg='Finished cleanUp, exiting')</span>
</code></dt>
<dd>
<div class="desc"><p>Garbage collect queues, threads, and cache.</p>
<p>By default, this wipes the cache. The idea being that if the
entire attack finished successfully, then it won't be
repeated and the cache isn't needed. Do <code>cleanUpCache=False</code>
if that isn't what you want.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanUp(self, cleanUpCache=True, doExit=False,
            exitMsg=&#34;Finished cleanUp, exiting&#34;):
    &#34;&#34;&#34; Garbage collect queues, threads, and cache.

        By default, this wipes the cache. The idea being that if the
        entire attack finished successfully, then it won&#39;t be
        repeated and the cache isn&#39;t needed. Do `cleanUpCache=False`
        if that isn&#39;t what you want.&#34;&#34;&#34;
    if self._vb: print(f&#34;Calling {__name__}.cleanUp&#34;)
    if self._rawQ.empty() != True:
        logging.warning(&#34;Warning, trying to clean up when raw queue not empty!&#34;)
    if self._anonQ.empty() != True:
        logging.warning(&#34;Warning, trying to clean up when anon queue not empty!&#34;)
    if self.cacheQueue.empty() != True:
        logging.warning(&#34;Warning, trying to clean up when cache queue not empty!&#34;)
    # Stuff in end signals for the workers (this is a bit bogus, cause
    # if a thread is gone or hanging, not all signals will get read)
    for i in range(self._p[&#39;numRawDbThreads&#39;]):
        self._rawQ.put(None)
    for i in range(self._p[&#39;numAnonDbThreads&#39;]):
        self._anonQ.put(None)

    for i in range(self.cacheQueue.qsize()):
        self.cacheQueue.put(None)

    cleanBgThreads()

    if len(self._p[&#39;pubDb&#39;]) &gt; 0:
        if self._pubQ.empty() != True:
            print(&#34;Warning, trying to clean up when pub queue not empty!&#34;)
        for i in range(self._p[&#39;numPubDbThreads&#39;]):
            self._pubQ.put(None)
        for t in self._pubThreads:
            if t.isAlive(): t.stop() # t.join()
    if cleanUpCache:
        self._removeLocalCacheDB()
    if doExit:
        sys.exit(exitMsg)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getAttack"><code class="name flex">
<span>def <span class="ident">getAttack</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the result of one askAttack() call</p>
<p>Blocks until the result is available. Note that the order
in which results are received is not necesarily the order
in which <code>askAttack()</code> calls were made. <br/>
Assuming <code>result</code> is returned: <br/>
<code>result['answer']</code> is the answer returned by the DB. The
format is: <br/>
<code>[(C1,C2&hellip;,Cn),(C1,C2&hellip;,Cn), &hellip; (C1,C2&hellip;,Cn)]</code> <br/>
where C1 is the first element of the <code>SELECT</code>, C2 the second
element, etc. <br/>
<code>result['cells']</code> is the number of cells returned in the answer
(used by <code><a title="gdascore.gdaAttack.gdaAttack" href="#gdascore.gdaAttack.gdaAttack">gdaAttack</a></code> to compute total attack cells) <br/>
<code>result['query']['sql']</code> is the query from the corresponding
<code>askAttack()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAttack(self):
    &#34;&#34;&#34; Returns the result of one askAttack() call

        Blocks until the result is available. Note that the order
        in which results are received is not necesarily the order
        in which `askAttack()` calls were made. &lt;br/&gt;
        Assuming `result` is returned: &lt;br/&gt;
        `result[&#39;answer&#39;]` is the answer returned by the DB. The
        format is: &lt;br/&gt;
            `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` &lt;br/&gt;
        where C1 is the first element of the `SELECT`, C2 the second
        element, etc. &lt;br/&gt;
        `result[&#39;cells&#39;]` is the number of cells returned in the answer
        (used by `gdaAttack()` to compute total attack cells) &lt;br/&gt;
        `result[&#39;query&#39;][&#39;sql&#39;]` is the query from the corresponding
        `askAttack()`.&#34;&#34;&#34;

    if self._vb:
        print(f&#34;Calling {__name__}.getAttack&#34;)
    if self._attackCounter == 0:
        # Caller shouldn&#39;t be calling if there are no expected
        # answers, but is anyway, so just return
        return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                &#39;stillToCome&#39;: 0}
    job = self._attackQ.get()
    self._attackQ.task_done()
    self._attackCounter -= 1
    reply = job[&#39;replies&#39;][0]
    reply[&#39;stillToCome&#39;] = self._attackCounter
    self._atrs[&#39;base&#39;][&#39;attackGets&#39;] += 1
    if &#39;cells&#39; in reply:
        if reply[&#39;cells&#39;] == 0:
            self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += 1
        else:
            self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += reply[&#39;cells&#39;]
    else:
        self._atrs[&#39;base&#39;][&#39;attackCells&#39;] += 1
    return (reply)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getAttackTableName"><code class="name flex">
<span>def <span class="ident">getAttackTableName</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the table being used in the attack.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAttackTableName(self):
    &#34;&#34;&#34;Returns the name of the table being used in the attack.&#34;&#34;&#34;
    return self._p[&#39;table&#39;]</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getClaim"><code class="name flex">
<span>def <span class="ident">getClaim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for and gather results of askClaim() calls</p>
<p>Returns a data structure that contains both the result
of one finished claim, and the claim's input parameters.
Note that the order in which results are returned by
<code>getClaim()</code> are not necessarily the same order they were
inserted by <code>askClaim()</code>. <br/>
Assuming <code>result</code> is returned: <br/>
<code>result['claim']</code> is the value supplied in the corresponding
<code>askClaim()</code> call <br/>
<code>result['spec']</code> is a copy of the <code>spec</code> supplied in the
corresponding <code>askClaim()</code> call. <br/>
<code>result['queries']</code> is a list of the queries generated in order to
validate the claim. <br/>
<code>result['answers']</code> are the answers to the queries in
<code>result['queries']</code>. <br/>
<code>result['claimResult']</code> is 'Correct' or 'Incorrect', depending
on whether the claim satisfies the critieria or not. <br/>
<code>result['stillToCome']</code> is a counter showing how many more
claims are still queued. When <code>stillToCome</code> is 0, then all
claims submitted by <code>askClaim()</code> have been returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getClaim(self):
    &#34;&#34;&#34; Wait for and gather results of askClaim() calls

        Returns a data structure that contains both the result
        of one finished claim, and the claim&#39;s input parameters.
        Note that the order in which results are returned by
        `getClaim()` are not necessarily the same order they were
        inserted by `askClaim()`. &lt;br/&gt;
        Assuming `result` is returned: &lt;br/&gt;
        `result[&#39;claim&#39;]` is the value supplied in the corresponding
        `askClaim()` call &lt;br/&gt;
        `result[&#39;spec&#39;]` is a copy of the `spec` supplied in the
        corresponding `askClaim()` call. &lt;br/&gt;
        `result[&#39;queries&#39;]` is a list of the queries generated in order to
        validate the claim. &lt;br/&gt;
        `result[&#39;answers&#39;]` are the answers to the queries in
        `result[&#39;queries&#39;]`. &lt;br/&gt;
        `result[&#39;claimResult&#39;]` is &#39;Correct&#39; or &#39;Incorrect&#39;, depending
        on whether the claim satisfies the critieria or not. &lt;br/&gt;
        `result[&#39;stillToCome&#39;]` is a counter showing how many more
        claims are still queued. When `stillToCome` is 0, then all
        claims submitted by `askClaim()` have been returned.&#34;&#34;&#34;

    if self._vb:
        print(f&#34;Calling {__name__}.getClaim&#34;)
    if self._claimCounter == 0:
        # Caller shouldn&#39;t be calling if there are no expected
        # answers, but is anyway, so just return
        return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                &#39;stillToCome&#39;: 0, &#39;claimResult&#39;: &#39;Error&#39;}
    job = self._claimQ.get()
    claim = job[&#39;claim&#39;]
    self._claimQ.task_done()
    self._claimCounter -= 1
    job[&#39;stillToCome&#39;] = self._claimCounter
    self._addToAtkRes(&#39;claimTrials&#39;, job[&#39;spec&#39;], 1)
    # The claim is tested against the first reply
    reply = job[&#39;replies&#39;][0]
    job[&#39;claimResult&#39;] = &#39;Wrong&#39;
    if claim:
        self._addToAtkRes(&#39;claimMade&#39;, job[&#39;spec&#39;], 1)
    if &#39;error&#39; in reply:
        self._addToAtkRes(&#39;claimError&#39;, job[&#39;spec&#39;], 1)
        job[&#39;claimResult&#39;] = &#39;Error&#39;
    else:
        if self._cr == &#39;singlingOut&#39;:
            claimIsCorrect = self._checkSinglingOut(reply[&#39;answer&#39;])
        elif self._cr == &#39;inference&#39;:
            claimIsCorrect = self._checkInference(reply[&#39;answer&#39;])
        elif self._cr == &#39;linkability&#39;:
            claimIsCorrect = self._checkLinkability(reply[&#39;answer&#39;])
        if claim == 1 and claimIsCorrect:
            self._addToAtkRes(&#39;claimCorrect&#39;, job[&#39;spec&#39;], 1)
            job[&#39;claimResult&#39;] = &#39;Correct&#39;
        elif claim == 0 and claimIsCorrect:
            self._addToAtkRes(&#39;claimPassCorrect&#39;, job[&#39;spec&#39;], 1)
            job[&#39;claimResult&#39;] = &#39;Correct&#39;
    if self._cr == &#39;singlingOut&#39; or self._cr == &#39;inference&#39;:
        # Then measure confidence against the second and third replies
        if &#39;answer&#39; in job[&#39;replies&#39;][1]:
            if job[&#39;replies&#39;][1][&#39;answer&#39;]:
                guessedRows = job[&#39;replies&#39;][1][&#39;answer&#39;][0][0]
            else:
                guessedRows = 0
        elif &#39;error&#39; in job[&#39;replies&#39;][1]:
            self._pp.pprint(job)
            print(f&#34;Error: conf query:\n{job[&#39;replies&#39;][1][&#39;error&#39;]}&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if &#39;answer&#39; in job[&#39;replies&#39;][2]:
            if job[&#39;replies&#39;][2][&#39;answer&#39;]:
                totalRows = job[&#39;replies&#39;][2][&#39;answer&#39;][0][0]
            else:
                totalRows = 0
        elif &#39;error&#39; in job[&#39;replies&#39;][2]:
            self._pp.pprint(job)
            print(f&#34;Error: conf query:\n{job[&#39;replies&#39;][2][&#39;error&#39;]}&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if totalRows:
            self._addToAtkRes(&#39;sumConfidenceRatios&#39;, job[&#39;spec&#39;],
                              guessedRows / totalRows)
            self._addToAtkRes(&#39;numConfidenceRatios&#39;, job[&#39;spec&#39;], 1)
            self._atrs[&#39;tableStats&#39;][&#39;totalRows&#39;] = totalRows
    else:
        # For linkability, the confidence is always 1/2
        self._addToAtkRes(&#39;sumConfidenceRatios&#39;, job[&#39;spec&#39;], 0.5)
        self._addToAtkRes(&#39;numConfidenceRatios&#39;, job[&#39;spec&#39;], 1)
    if &#39;q&#39; in job:
        del job[&#39;q&#39;]
    return (job)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getColNames"><code class="name flex">
<span>def <span class="ident">getColNames</span></span>(<span>self, dbType='rawDb', tableName='')</span>
</code></dt>
<dd>
<div class="desc"><p>Return simple list of column names</p>
<p><code>dbType</code> is one of 'rawDb' or 'anonDb'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getColNames(self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;):
    &#34;&#34;&#34;Return simple list of column names

    `dbType` is one of &#39;rawDb&#39; or &#39;anonDb&#39;&#34;&#34;&#34;

    if len(tableName) == 0:
        colsAndTypes = self.getColNamesAndTypes(dbType=dbType)
    else:
        colsAndTypes = self.getColNamesAndTypes(
            dbType=dbType, tableName=tableName)
    if not colsAndTypes:
        return None
    cols = []
    for tup in colsAndTypes:
        cols.append(tup[0])
    return cols</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getColNamesAndTypes"><code class="name flex">
<span>def <span class="ident">getColNamesAndTypes</span></span>(<span>self, dbType='rawDb', tableName='')</span>
</code></dt>
<dd>
<div class="desc"><p>Return raw database column names and types (or None if error)</p>
<p>dbType is one of 'rawDb' or 'anonDb' <br/>
return format: [(col,type),(col,type),&hellip;]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getColNamesAndTypes(self, dbType=&#39;rawDb&#39;, tableName=&#39;&#39;):
    &#34;&#34;&#34;Return raw database column names and types (or None if error)

    dbType is one of &#39;rawDb&#39; or &#39;anonDb&#39; &lt;br/&gt;
    return format: [(col,type),(col,type),...]&#34;&#34;&#34;
    if len(tableName) == 0:
        # caller didn&#39;t supply a table name, so get it from the
        # class init
        tableName = self._p[&#39;table&#39;]

    # Establish connection to database
    db = getDatabaseInfo(self._p[dbType])
    if db[&#39;type&#39;] != &#39;postgres&#39; and db[&#39;type&#39;] != &#39;aircloak&#39;:
        print(f&#34;DB type &#39;{db[&#39;type&#39;]}&#39; must be &#39;postgres&#39; or &#39;aircloak&#39;&#34;)
        return None
    connStr = str(
        f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # Query it for column names
    if db[&#39;type&#39;] == &#39;postgres&#39;:
        sql = str(f&#34;&#34;&#34;select column_name, data_type 
                  from information_schema.columns where
                  table_name=&#39;{tableName}&#39;&#34;&#34;&#34;)
    elif db[&#39;type&#39;] == &#39;aircloak&#39;:
        sql = str(f&#34;show columns from {tableName}&#34;)
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f&#34;Error: getColNamesAndTypes() query: &#39;{e}&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    ret = []
    for row in ans:
        ret.append((row[0], row[1]))
    conn.close()
    return ret</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getExplore"><code class="name flex">
<span>def <span class="ident">getExplore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for and gather results of prior askExplore() calls.</p>
<p>Blocks until the result is available. Note that the order
in which results are received is not necesarily the order
in which <code>askExplore()</code> calls were made. <br/>
Return parameter formatted the same as with <code>getAttack()</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExplore(self):
    &#34;&#34;&#34; Wait for and gather results of prior askExplore() calls.

        Blocks until the result is available. Note that the order
        in which results are received is not necesarily the order
        in which `askExplore()` calls were made. &lt;br/&gt;
        Return parameter formatted the same as with `getAttack()`&#34;&#34;&#34;
    if self._vb:
        print(f&#34;Calling {__name__}.getExplore&#34;)
    if self._exploreCounter == 0:
        # Caller shouldn&#39;t be calling if there are no expected
        # answers, but is anyway, so just return
        return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                &#39;stillToCome&#39;: 0}
    job = self._exploreQ.get()
    self._exploreQ.task_done()
    self._exploreCounter -= 1
    reply = job[&#39;replies&#39;][0]
    reply[&#39;stillToCome&#39;] = self._exploreCounter
    return (reply)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getKnowledge"><code class="name flex">
<span>def <span class="ident">getKnowledge</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for and gather results of prior askKnowledge() calls</p>
<p>Blocks until the result is available. Note that the order
in which results are received is not necesarily the order
in which <code>askKnowledge()</code> calls were made. <br/>
Return parameter formatted the same as with <code>getAttack()</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKnowledge(self):
    &#34;&#34;&#34; Wait for and gather results of prior askKnowledge() calls

        Blocks until the result is available. Note that the order
        in which results are received is not necesarily the order
        in which `askKnowledge()` calls were made. &lt;br/&gt;
        Return parameter formatted the same as with `getAttack()`&#34;&#34;&#34;

    if self._vb:
        print(f&#34;Calling {__name__}.getKnowledge&#34;)
    if self._knowledgeCounter == 0:
        # Caller shouldn&#39;t be calling if there are no expected
        # answers, but is anyway, so just return
        return {&#39;query&#39;: {&#39;sql&#39;: &#39;None&#39;}, &#39;error&#39;: &#39;Nothing to do&#39;,
                &#39;stillToCome&#39;: 0}
    job = self._knowledgeQ.get()
    self._knowledgeQ.task_done()
    self._knowledgeCounter -= 1
    reply = job[&#39;replies&#39;][0]
    reply[&#39;stillToCome&#39;] = self._knowledgeCounter
    self._atrs[&#39;base&#39;][&#39;knowledgeGets&#39;] += 1
    if &#39;cells&#39; in reply:
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += reply[&#39;cells&#39;]
    return (reply)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getOpParameters"><code class="name flex">
<span>def <span class="ident">getOpParameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a variety of performance measurements.</p>
<p>Useful for debugging.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOpParameters(self):
    &#34;&#34;&#34; Returns a variety of performance measurements.

        Useful for debugging.&#34;&#34;&#34;
    self._op[&#39;avQueryDuration&#39;] = 0
    if self._op[&#39;numQueries&#39;] &gt; 0:
        self._op[&#39;avQueryDuration&#39;] = (
                self._op[&#39;timeQueries&#39;] / self._op[&#39;numQueries&#39;])
    self._op[&#39;avCachePutDuration&#39;] = 0
    if self._op[&#39;numCachePuts&#39;] &gt; 0:
        self._op[&#39;avCachePutDuration&#39;] = (
                self._op[&#39;timeCachePuts&#39;] / self._op[&#39;numCachePuts&#39;])
    self._op[&#39;avCacheGetDuration&#39;] = 0
    if self._op[&#39;numCacheGets&#39;] &gt; 0:
        self._op[&#39;avCacheGetDuration&#39;] = (
                self._op[&#39;timeCacheGets&#39;] / self._op[&#39;numCacheGets&#39;])
    return self._op</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getPriorKnowledge"><code class="name flex">
<span>def <span class="ident">getPriorKnowledge</span></span>(<span>self, dataColumns, method, fraction=None, count=None, selectColumn=None, colRange=[None, None], values=[None])</span>
</code></dt>
<dd>
<div class="desc"><p>Returns data from the rawDB according to a specification</p>
<p>This mimics external knowledge that an attacker may have about the data, and
influences the 'knowledge' part of the GDA Score. <br/>
<code>dataColumns</code> is a list of column names. The data for these columns is returned <br/>
<code>method</code> can be 'rows' or 'users'. If 'rows', then rows are selected
according to the criteria (<code>fraction</code>, <code>count</code>, <code>selectColumn</code>, <code>colRange</code>,
or <code>values</code>).
If 'users', then all rows for a set of selected users is returned.
The users are selected according to the criteria (<code>fraction</code> or <code>count</code>) <br/>
If none of the criteria are set, or if <code>fraction</code> is set to 1.0, then all
rows are returned (for the selected column values) One of <code>fraction</code>, <code>count</code>,
or <code>selectColumn</code> must be set. <br/>
<code>fraction</code> or <code>count</code> are set to obtain a random set of rows or users. If
<code>fraction</code>, then an approximate fraction of all rows/users is selected.
<code>fraction</code> is a value between 0 and 1.0. If <code>count</code>, then exactly <code>count</code>
random rows/users are selected. <br/>
<code>selectColumn</code> is set to select rows according to the values of the specified
column. <code>selectColumn</code> is a column name. If set, then either a range of
values (<code>colRange</code>), or a set of values (<code>values</code>) must be chosen. <br/>
<code>colRange</code> is
a list with two values: <code>[min,max]</code>. This selects all values
between min and max inclusive. <br/>
<code>values</code> is a list
of one or more values of any type. This selects all values matching those in
the list. <br/>
The return value is a list in this format: <br/>
<code>[(C1,C2&hellip;,Cn),(C1,C2&hellip;,Cn), &hellip; (C1,C2&hellip;,Cn)]</code> <br/>
where C1 corresponds to the first column in <code>dataColumns</code>, C2 corresponds to
the second column in <code>dataColumns</code>, and so on.
<br/></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPriorKnowledge(self, dataColumns, method,
        fraction=None, count=None, selectColumn=None, colRange=[None,None], values=[None]):
    &#34;&#34;&#34; Returns data from the rawDB according to a specification

    This mimics external knowledge that an attacker may have about the data, and
    influences the &#39;knowledge&#39; part of the GDA Score. &lt;br/&gt;
        `dataColumns` is a list of column names. The data for these columns is returned &lt;br/&gt;
        `method` can be &#39;rows&#39; or &#39;users&#39;. If &#39;rows&#39;, then rows are selected
        according to the criteria (`fraction`, `count`, `selectColumn`, `colRange`,
        or `values`).
        If &#39;users&#39;, then all rows for a set of selected users is returned.
        The users are selected according to the criteria (`fraction` or `count`) &lt;br/&gt;
        If none of the criteria are set, or if `fraction` is set to 1.0, then all
        rows are returned (for the selected column values) One of `fraction`, `count`,
        or `selectColumn` must be set. &lt;br/&gt;
        `fraction` or `count` are set to obtain a random set of rows or users. If
        `fraction`, then an approximate fraction of all rows/users is selected.
        `fraction` is a value between 0 and 1.0. If `count`, then exactly `count`
        random rows/users are selected. &lt;br/&gt;
        `selectColumn` is set to select rows according to the values of the specified
        column. `selectColumn` is a column name. If set, then either a range of
        values (`colRange`), or a set of values (`values`) must be chosen. &lt;br/&gt;
        `colRange` is
        a list with two values: `[min,max]`. This selects all values
        between min and max inclusive. &lt;br/&gt;
        `values` is a list
        of one or more values of any type. This selects all values matching those in
        the list. &lt;br/&gt;
        The return value is a list in this format: &lt;br/&gt;
            `[(C1,C2...,Cn),(C1,C2...,Cn), ... (C1,C2...,Cn)]` &lt;br/&gt;
        where C1 corresponds to the first column in `dataColumns`, C2 corresponds to
        the second column in `dataColumns`, and so on.  &lt;br/&gt;
    &#34;&#34;&#34;
    # Check input parameters
    if not isinstance(dataColumns, list):
        print(f&#34;getPriorKnowledge Error: dataColumns must be a list of one or more column names&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    if method not in [&#39;rows&#39;,&#39;users&#39;]:
        print(f&#34;getPriorKnowledge Error: method must be &#39;rows&#39; or &#39;users&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    if fraction is None and count is None and selectColumn is None:
        print(f&#34;getPriorKnowledge Error: one of fraction, count, or selectColumn must be set&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    if fraction and not isinstance(fraction, float):
        print(f&#34;getPriorKnowledge Error: if set, fraction must be a float&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    if (fraction and (count or selectColumn)) or (count and (fraction or selectColumn)):
        print(f&#34;getPriorKnowledge Error: only one of fraction, count, or selectColumn may be set&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    if count and not isinstance(count, int):
        print(f&#34;getPriorKnowledge Error: if set, count must be an integer&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    if selectColumn:
        if selectColumn not in self._colNames:
            print(f&#34;getPriorKnowledge Error: selectColumn &#39;{selectColumn}&#39; is not a valid column&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if colRange == [None,None] and values == [None]:
            print(f&#34;getPriorKnowledge Error: if selectColumn is set, one of colRange or values must be set&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if not isinstance(colRange, list):
            print(f&#34;getPriorKnowledge Error: colRange must be a list with two values&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
        if not (isinstance(values, list) or isinstance(values, tuple)) or len(values) == 0:
            print(f&#34;getPriorKnowledge Error: values must be a list or tuple with one or more values&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
    for col in dataColumns:
        if col not in self._colNames:
            print(f&#34;getPriorKnowledge Error: column &#39;{col}&#39; is not a valid column&#34;)
            self.cleanUp(cleanUpCache=False, doExit=True)
    # Basic input checks finished
    # Establish connection to database
    db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
    connStr = str(
        f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    table = self._p[&#39;table&#39;]
    uid = self._p[&#39;uid&#39;]
    # Make the SELECT part of the SQL query
    initSql = &#39;SELECT &#39;
    for col in dataColumns:
        initSql += str(f&#34;{col}, &#34;)
    initSql = initSql[0:-2]
    if method == &#39;rows&#39; and fraction:
        sql = initSql + str(f&#34; FROM {table} WHERE random() &lt;= {fraction}&#34;)
        ans = self._doQuery(cur,sql)
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
        return(ans)
    if method == &#39;users&#39; and fraction:
        sql = initSql + str(f&#34; FROM {table} WHERE {uid} IN &#34;)
        sql += str(f&#34;(SELECT {uid} from (SELECT DISTINCT {uid} FROM {table}) t WHERE random() &lt; {fraction})&#34;)
        ans = self._doQuery(cur,sql)
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
        return(ans)
    if method == &#39;rows&#39; and colRange[0] is not None:
        for pair in self._colNamesTypes:
            if selectColumn in pair[0]:
                colType = pair[1]
                break
        if &#39;text&#39; in colType or &#39;char&#39; in colType or &#39;date&#39; in colType or &#39;time&#39; in colType:
            sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} &gt;= &#39;{colRange[0]}&#39; and {selectColumn} &lt;= &#39;{colRange[1]}&#39;&#34;)
        else:
            sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} &gt;= {colRange[0]} and {selectColumn} &lt;= {colRange[1]}&#34;)
        ans = self._doQuery(cur,sql)
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
        return(ans)
    if method == &#39;rows&#39; and values[0] is not None:
        sql = initSql + str(f&#34; FROM {table} WHERE {selectColumn} IN (&#34;)
        for pair in self._colNamesTypes:
            if selectColumn in pair[0]:
                colType = pair[1]
                break
        for value in values:
            if &#34;text&#34; in colType or &#34;date&#34; in colType or &#34;time&#34; in colType:
                sql += str(f&#34;&#39;{value}&#39;, &#34;)
            else:
                sql += str(f&#34;{value}, &#34;)
        sql = sql[0:-2]
        sql += &#34;)&#34;
        ans = self._doQuery(cur,sql)
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
        return(ans)
    if method == &#39;rows&#39; and count:
        # need to know the total number of rows
        sql = str(f&#34;select count(*) from {table}&#34;)
        ans = self._doQuery(cur,sql)
        numRows = ans[0][0]
        # next we get some random set of rows that is certainly more than we need
        frac = (count/numRows)*2
        sql = initSql + str(f&#34; FROM {table} WHERE random() &lt;= {frac}&#34;)
        temp = self._doQuery(cur,sql)
        # next we scramble these so that we get a random sampling from the random sampling
        random.shuffle(temp)
        # finally pick the exact count
        ans = temp[0:count]
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
        return(ans)
    if method == &#39;users&#39; and count:
        # get the full list of distinct UIDs
        sql = str(f&#34;SELECT DISTINCT {uid} from {table}&#34;)
        uidList = self._doQuery(cur,sql)
        # next we scramble these so that we can get a random sampling
        random.shuffle(uidList)
        # pick the exact count of UIDs
        uidList = uidList[0:count]
        sql = initSql + str(f&#34; FROM {table} WHERE {uid} IN (&#34;)
        for pair in self._colNamesTypes:
            if uid in pair[0]:
                colType = pair[1]
                break
        for uidVal in uidList:
            if &#34;text&#34; in colType or &#34;date&#34; in colType or &#34;time&#34; in colType:
                sql += str(f&#34;&#39;{uidVal[0]}&#39;, &#34;)
            else:
                sql += str(f&#34;{uidVal[0]}, &#34;)
        sql = sql[0:-2]
        sql += &#34;)&#34;
        ans = self._doQuery(cur,sql)
        self._atrs[&#39;base&#39;][&#39;knowledgeCells&#39;] += len(dataColumns) * len(ans)
        return(ans)
    #zzzz
    return None</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getPublicColValues"><code class="name flex">
<span>def <span class="ident">getPublicColValues</span></span>(<span>self, colName, tableName='')</span>
</code></dt>
<dd>
<div class="desc"><p>Return list of "publicly known" column values and counts</p>
<p>Column value has index 0, count of distinct UIDs has index 1
Must specify column name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPublicColValues(self, colName, tableName=&#39;&#39;):
    &#34;&#34;&#34;Return list of &#34;publicly known&#34; column values and counts

    Column value has index 0, count of distinct UIDs has index 1
    Must specify column name.
    &#34;&#34;&#34;
    if len(colName) == 0:
        print(f&#34;Must specify column &#39;colName&#39;&#34;)
        return None

    if len(tableName) == 0:
        # caller didn&#39;t supply a table name, so get it from the
        # class init
        tableName = self._p[&#39;table&#39;]

    # Establish connection to database
    db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
    connStr = str(
        f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # First we need to know the total number of distinct users
    sql = str(f&#34;&#34;&#34;select count(distinct {self._p[&#39;uid&#39;]})
                  from {tableName}&#34;&#34;&#34;)
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    numUid = ans[0][0]
    # Query the raw db for values in the column
    sql = str(f&#34;&#34;&#34;select {colName}, count(distinct {self._p[&#39;uid&#39;]})
                  from {tableName}
                  group by 1
                  order by 2 desc
                  limit 200&#34;&#34;&#34;)
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f&#34;Error: getPublicColValues() query: &#39;{e}&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    ret = []
    for row in ans:
        # row[0] is the value, row[1] is the count
        if (((row[1] / numUid) &gt; 0.002) and
                (row[1] &gt;= 50)):
            ret.append((row[0], row[1]))
    conn.close()
    return ret</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getResults"><code class="name flex">
<span>def <span class="ident">getResults</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all of the compiled attack results.</p>
<p>This can be input to class <code>gdaScores()</code> and method
<code>gdaScores.addResult()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResults(self):
    &#34;&#34;&#34; Returns all of the compiled attack results.

        This can be input to class `gdaScores()` and method
        `gdaScores.addResult()`.&#34;&#34;&#34;
    # Add the operational parameters
    self._atrs[&#39;operational&#39;] = self.getOpParameters()
    self._cleanPasswords()
    return self._atrs</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getTableCharacteristics"><code class="name flex">
<span>def <span class="ident">getTableCharacteristics</span></span>(<span>self, tableName='')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the full contents of the table characteristics</p>
<p>Return value is a dict indexed by column name: <br/></p>
<pre><code>{ '&lt;colName&gt;':
    {
        'av_rows_per_vals': 3.93149,
        'av_uids_per_val': 0.468698,
        'column_label': 'continuous',
        'column_name': 'dropoff_latitude',
        'column_type': 'real',
        'max': '898.29382000000000',
        'min': '-0.56333297000000',
        'num_distinct_vals': 24216,
        'num_rows': 95205,
        'num_uids': 11350,
        'std_rows_per_val': 10.8547,
        'std_uids_per_val': 4.09688},
    }
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTableCharacteristics(self, tableName=&#39;&#39;):
    &#34;&#34;&#34;Returns the full contents of the table characteristics

       Return value is a dict indexed by column name: &lt;br/&gt;

           { &#39;&lt;colName&gt;&#39;:
               {
                   &#39;av_rows_per_vals&#39;: 3.93149,
                   &#39;av_uids_per_val&#39;: 0.468698,
                   &#39;column_label&#39;: &#39;continuous&#39;,
                   &#39;column_name&#39;: &#39;dropoff_latitude&#39;,
                   &#39;column_type&#39;: &#39;real&#39;,
                   &#39;max&#39;: &#39;898.29382000000000&#39;,
                   &#39;min&#39;: &#39;-0.56333297000000&#39;,
                   &#39;num_distinct_vals&#39;: 24216,
                   &#39;num_rows&#39;: 95205,
                   &#39;num_uids&#39;: 11350,
                   &#39;std_rows_per_val&#39;: 10.8547,
                   &#39;std_uids_per_val&#39;: 4.09688},
               }
           }

    &#34;&#34;&#34;
    if len(tableName) == 0:
        # caller didn&#39;t supply a table name, so get it from the
        # class init
        tableName = self._p[&#39;table&#39;]

    # Modify table name to the default for the characteristics table
    tableName += &#39;_char&#39;

    # Establish connection to database
    db = getDatabaseInfo(self._p[&#39;rawDb&#39;])
    connStr = str(
        f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # Set up return dict
    ret = {}
    # Query it for column names
    sql = str(f&#34;&#34;&#34;select column_name, data_type 
              from information_schema.columns where
              table_name=&#39;{tableName}&#39;&#34;&#34;&#34;)
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f&#34;Error: getTableCharacteristics() query: &#39;{e}&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    cols = cur.fetchall()
    # Make index for column name (should be 0, but just to be sure)
    for colNameIndex in range(len(cols)):
        if cols[colNameIndex][0] == &#39;column_name&#39;:
            break

    # Query it for table contents
    sql = str(f&#34;SELECT * FROM {tableName}&#34;)
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f&#34;Error: getTableCharacteristics() query: &#39;{e}&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    for row in ans:
        colName = row[colNameIndex]
        ret[colName] = {}
        for i in range(len(row)):
            ret[colName][cols[i][0]] = row[i]
    conn.close()
    return ret</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getTableNames"><code class="name flex">
<span>def <span class="ident">getTableNames</span></span>(<span>self, dbType='rawDb')</span>
</code></dt>
<dd>
<div class="desc"><p>Return database table names</p>
<p>dbType is one of 'rawDb' or 'anonDb' <br/>
Table names returned as list, unless error then return None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTableNames(self, dbType=&#39;rawDb&#39;):
    &#34;&#34;&#34;Return database table names

    dbType is one of &#39;rawDb&#39; or &#39;anonDb&#39; &lt;br/&gt;
    Table names returned as list, unless error then return None&#34;&#34;&#34;

    # Establish connection to database
    db = getDatabaseInfo(self._p[dbType])
    if db[&#39;type&#39;] != &#39;postgres&#39; and db[&#39;type&#39;] != &#39;aircloak&#39;:
        print(f&#34;DB type &#39;{db[&#39;type&#39;]}&#39; must be &#39;postgres&#39; or &#39;aircloak&#39;&#34;)
        return None
    connStr = str(
        f&#34;host={db[&#39;host&#39;]} port={db[&#39;port&#39;]} dbname={db[&#39;dbname&#39;]} user={db[&#39;user&#39;]} password={db[&#39;password&#39;]}&#34;)
    conn = psycopg2.connect(connStr)
    cur = conn.cursor()
    # Query it for column names
    if db[&#39;type&#39;] == &#39;postgres&#39;:
        sql = &#34;&#34;&#34;SELECT tablename
                 FROM pg_catalog.pg_tables
                 WHERE schemaname != &#39;pg_catalog&#39; AND
                       schemaname != &#39;information_schema&#39;&#34;&#34;&#34;
    elif db[&#39;type&#39;] == &#39;aircloak&#39;:
        sql = &#34;show tables&#34;
    try:
        cur.execute(sql)
    except psycopg2.Error as e:
        print(f&#34;Error: getTableNames() query: &#39;{e}&#39;&#34;)
        self.cleanUp(cleanUpCache=False, doExit=True)
    ans = cur.fetchall()
    ret = []
    for row in ans:
        ret.append(row[0])
    conn.close()
    return ret</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.getUidColName"><code class="name flex">
<span>def <span class="ident">getUidColName</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the name of the UID column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUidColName(self):
    &#34;&#34;&#34; Returns the name of the UID column&#34;&#34;&#34;
    return self._p[&#39;uid&#39;]</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.isClaimed"><code class="name flex">
<span>def <span class="ident">isClaimed</span></span>(<span>self, spec)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a claim was already fully or partially made.</p>
<p>The <code>spec</code> is formatted identical to the <code>spec</code> in <code><a title="gdascore.gdaAttack.gdaAttack.askClaim" href="#gdascore.gdaAttack.gdaAttack.askClaim">gdaAttack.askClaim()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isClaimed(self, spec):
    &#34;&#34;&#34;Check if a claim was already fully or partially made.

    The `spec` is formatted identical to the `spec` in `gdaAttack.askClaim`.&#34;&#34;&#34;
    return self._dupCheck.is_claimed(spec, verbose=self._vb)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.putCacheWrapper"><code class="name flex">
<span>def <span class="ident">putCacheWrapper</span></span>(<span>self, conn, cur, query, reply)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def putCacheWrapper(self, conn, cur, query, reply):
    self._putCache(conn, cur, query, reply)</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.removeLocalCacheDBWrapper"><code class="name flex">
<span>def <span class="ident">removeLocalCacheDBWrapper</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeLocalCacheDBWrapper(self):
    return self._removeLocalCacheDB()</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.setVerbose"><code class="name flex">
<span>def <span class="ident">setVerbose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Verbose to True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setVerbose(self):
    &#34;&#34;&#34;Sets Verbose to True&#34;&#34;&#34;
    self._vb = True</code></pre>
</details>
</dd>
<dt id="gdascore.gdaAttack.gdaAttack.unsetVerbose"><code class="name flex">
<span>def <span class="ident">unsetVerbose</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Verbose to False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsetVerbose(self):
    &#34;&#34;&#34;Sets Verbose to False&#34;&#34;&#34;
    self._vb = False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<a href="https://www.gda-score.org/" class="custom-logo-link" rel="home" itemprop="url">
<img src="https://www.gda-score.org/wp-content/uploads/2018/10/GDA_Logo_04.svg" width="250" class="custom-logo" alt="GDA Score"
itemprop="logo" />
</a>
<hr style="margin-top:20px;" />
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gdascore" href="index.html">gdascore</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gdascore.gdaAttack.gdaAttack" href="#gdascore.gdaAttack.gdaAttack">gdaAttack</a></code></h4>
<ul class="">
<li><code><a title="gdascore.gdaAttack.gdaAttack.askAttack" href="#gdascore.gdaAttack.gdaAttack.askAttack">askAttack</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.askClaim" href="#gdascore.gdaAttack.gdaAttack.askClaim">askClaim</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.askExplore" href="#gdascore.gdaAttack.gdaAttack.askExplore">askExplore</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.askKnowledge" href="#gdascore.gdaAttack.gdaAttack.askKnowledge">askKnowledge</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.cleanUp" href="#gdascore.gdaAttack.gdaAttack.cleanUp">cleanUp</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getAttack" href="#gdascore.gdaAttack.gdaAttack.getAttack">getAttack</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getAttackTableName" href="#gdascore.gdaAttack.gdaAttack.getAttackTableName">getAttackTableName</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getClaim" href="#gdascore.gdaAttack.gdaAttack.getClaim">getClaim</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getColNames" href="#gdascore.gdaAttack.gdaAttack.getColNames">getColNames</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getColNamesAndTypes" href="#gdascore.gdaAttack.gdaAttack.getColNamesAndTypes">getColNamesAndTypes</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getExplore" href="#gdascore.gdaAttack.gdaAttack.getExplore">getExplore</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getKnowledge" href="#gdascore.gdaAttack.gdaAttack.getKnowledge">getKnowledge</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getOpParameters" href="#gdascore.gdaAttack.gdaAttack.getOpParameters">getOpParameters</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getPriorKnowledge" href="#gdascore.gdaAttack.gdaAttack.getPriorKnowledge">getPriorKnowledge</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getPublicColValues" href="#gdascore.gdaAttack.gdaAttack.getPublicColValues">getPublicColValues</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getResults" href="#gdascore.gdaAttack.gdaAttack.getResults">getResults</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getTableCharacteristics" href="#gdascore.gdaAttack.gdaAttack.getTableCharacteristics">getTableCharacteristics</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getTableNames" href="#gdascore.gdaAttack.gdaAttack.getTableNames">getTableNames</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.getUidColName" href="#gdascore.gdaAttack.gdaAttack.getUidColName">getUidColName</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.isClaimed" href="#gdascore.gdaAttack.gdaAttack.isClaimed">isClaimed</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.putCacheWrapper" href="#gdascore.gdaAttack.gdaAttack.putCacheWrapper">putCacheWrapper</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.removeLocalCacheDBWrapper" href="#gdascore.gdaAttack.gdaAttack.removeLocalCacheDBWrapper">removeLocalCacheDBWrapper</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.setVerbose" href="#gdascore.gdaAttack.gdaAttack.setVerbose">setVerbose</a></code></li>
<li><code><a title="gdascore.gdaAttack.gdaAttack.unsetVerbose" href="#gdascore.gdaAttack.gdaAttack.unsetVerbose">unsetVerbose</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<!--<a href="https://www.gda-score.org/legal-notice/">Legal notice</a>&nbsp;&nbsp;&nbsp;
<a href="https://www.gda-score.org/privacy-policy/">Privacy policy</a>-->
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>